<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bella</title>
  
  <subtitle>收集人生成就中</subtitle>
  <link href="https://www.bebella.cc/atom.xml" rel="self"/>
  
  <link href="https://www.bebella.cc/"/>
  <updated>2023-07-06T13:23:08.030Z</updated>
  <id>https://www.bebella.cc/</id>
  
  <author>
    <name>Bella</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【算法】双链表</title>
    <link href="https://www.bebella.cc/2023/07/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.bebella.cc/2023/07/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8F%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2023-07-06T13:00:56.000Z</published>
    <updated>2023-07-06T13:23:08.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="827-双链表"><a href="#827-双链表" class="headerlink" title="827. 双链表"></a>827. 双链表</h3><p>实现一个双链表，双链表初始为空，支持 55 种操作：</p><ol><li>在最左侧插入一个数；</li><li>在最右侧插入一个数；</li><li>将第 k  个插入的数删除；</li><li>在第 k  个插入的数左侧插入一个数；</li><li>在第 k  个插入的数右侧插入一个数</li></ol><p>现在要对该链表进行 M  次操作，进行完所有操作后，从左到右输出整个链表。</p><p><strong>注意</strong>:题目中第 k  个插入的数并不是指当前链表的第 k  个数。例如操作过程中一共插入了 n  个数，则按照插入的时间顺序，这 n  个数依次为：第 11 个插入的数，第 22 个插入的数，…第 n  个插入的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M ，表示操作次数。</p><p>接下来 M  行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>L x</code>，表示在链表的最左端插入数 x 。</li><li><code>R x</code>，表示在链表的最右端插入数 x 。</li><li><code>D k</code>，表示将第 k  个插入的数删除。</li><li><code>IL k x</code>，表示在第 k  个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 k  个插入的数右侧插入一个数。</li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从左到右输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤1000001≤ ≤100000<br>所有操作保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">R 7</span><br><span class="line">D 1</span><br><span class="line">L 3</span><br><span class="line">IL 2 10</span><br><span class="line">D 3</span><br><span class="line">IL 2 7</span><br><span class="line">L 8</span><br><span class="line">R 9</span><br><span class="line">IL 4 7</span><br><span class="line">IR 2 2</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 7 7 3 2 9</span><br></pre></td></tr></table></figure><h4 id="和单链表的不同："><a href="#和单链表的不同：" class="headerlink" title="和单链表的不同："></a>和单链表的不同：</h4><p><code>ne</code>变成了<code>l[]</code>和<code>r[]</code>，左右两个指针。</p><p>进行增加、删除操作时需要注意先后顺序。</p><p>初始化时，将0,1分别定为头节点和尾节点。</p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0表示最左侧，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标k出右边插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="comment">// 操作符 用字符表示</span></span><br><span class="line">        string op;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">// 插入最右边</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">// 插入最左边</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k + <span class="number">1</span>], x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;827-双链表&quot;&gt;&lt;a href=&quot;#827-双链表&quot; class=&quot;headerlink&quot; title=&quot;827. 双链表&quot;&gt;&lt;/a&gt;827. 双链表&lt;/h3&gt;&lt;p&gt;实现一个双链表，双链表初始为空，支持 55 种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在最左侧插入一个</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bebella.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="编程" scheme="https://www.bebella.cc/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="AcWing" scheme="https://www.bebella.cc/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【算法】单链表</title>
    <link href="https://www.bebella.cc/2023/07/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.bebella.cc/2023/07/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2023-07-06T12:11:44.000Z</published>
    <updated>2023-07-06T13:00:28.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="826-单链表"><a href="#826-单链表" class="headerlink" title="826. 单链表"></a>826. 单链表</h3><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 k 个插入的数后面的数；</li><li>在第 k 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k  个插入的数并不是指当前链表的第 k  个数。例如操作过程中一共插入了 n  个数，则按照插入的时间顺序，这 n  个数依次为：第 11 个插入的数，第 22 个插入的数，…第 n  个插入的数。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M ，表示操作次数。</p><p>接下来 M  行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>H x</code>，表示向链表头插入一个数 x 。</li><li><code>D k</code>，表示删除第 k  个插入的数后面的数（当 k  为 00 时，表示删除头结点）。</li><li><code>I k x</code>，表示在第 k  个插入的数后面插入一个数 x （此操作中 k  均大于 00）。</li></ol><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤1000001≤ ≤100000<br>所有操作保证合法。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>本题的根本要求：构造一个单链表，并最后输出这个链表的元素。</p><p>核心思路：数组来模拟链表。</p><p>共有三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 k 个插入的数后面的数；</li><li>在第 k 个插入的数后插入一个数。</li></ol><p>核心思路：数组来模拟链表。</p><h5 id="符号说明："><a href="#符号说明：" class="headerlink" title="符号说明："></a>符号说明：</h5><p>用<code>e[N]</code>，<code>ne[N]</code>分别表示该点的值和下一个指针。<code>ne[]</code>的值直接指向数组下标。</p><p><code>head</code>表示头节点，<code>idx</code>存储现在已经用到的点</p><h5 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h5><p>1. </p><h4 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 头节点的下标</span></span><br><span class="line"><span class="comment">// e[i] 节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示i的next指针</span></span><br><span class="line"><span class="comment">// idx 存储已经用到的节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x插入头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个插入的书后面的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_k</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x; </span><br><span class="line">    ne[idx] = ne[k]; </span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k插入数后面的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="comment">// 操作符 用字符表示</span></span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="comment">// 若删除的是头节点</span></span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_k</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h4><ol><li><p>为什么不用结构体实现而用数组？</p><p>结构体new的耗时长，容易超时。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;826-单链表&quot;&gt;&lt;a href=&quot;#826-单链表&quot; class=&quot;headerlink&quot; title=&quot;826. 单链表&quot;&gt;&lt;/a&gt;826. 单链表&lt;/h3&gt;&lt;p&gt;实现一个单链表，链表初始为空，支持三种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向链表头插入一个数；&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bebella.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="编程" scheme="https://www.bebella.cc/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="AcWing" scheme="https://www.bebella.cc/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【算法】KMP算法</title>
    <link href="https://www.bebella.cc/2023/07/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/"/>
    <id>https://www.bebella.cc/2023/07/01/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91KMP%E7%AE%97%E6%B3%95/</id>
    <published>2023-07-01T13:56:27.000Z</published>
    <updated>2023-07-01T14:32:02.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率高。</p><p>首先约定：<code>pat</code>表示模式串，长度为<code>M</code>，文本串为<code>txt</code>，文本串长度为<code>N</code>。</p><p>KMP算法即在文本串<code>txt</code>中匹配子串<code>pat</code>；若存在， 返回这个子串的起始索引，否则返回-1。</p><h3 id="二、KMP算法概述"><a href="#二、KMP算法概述" class="headerlink" title="二、KMP算法概述"></a>二、KMP算法概述</h3><h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 暴力匹配（伪码）</span><br><span class="line">int search(String pat, String txt) &#123;</span><br><span class="line">    int M = pat.length; </span><br><span class="line">    int N = txt.length;</span><br><span class="line">    for (int i = 0; i &lt;= N - M; i++) &#123;</span><br><span class="line">        int j;</span><br><span class="line">        for (j = 0; j &lt; M; j++) &#123;</span><br><span class="line">            if (pat[j] != txt[i+j]) // 匹配不上</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        // pat 全都匹配了</span><br><span class="line">        if (j == M) return i;</span><br><span class="line">    &#125;</span><br><span class="line">    // txt 中不存在 pat 子串</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于暴力算法，如果出现不匹配字符，同时回退 <code>txt</code> 和 <code>pat</code> 的指针，嵌套 for 循环，时间复杂度 <code>O(MN)</code>，空间复杂度<code>O(1)</code>。最主要的问题是，如果字符串中重复的字符比较多，暴力解法明显多做了很多不必要的操作，耗时长。</p><p>而KMPP算法会花费空间来记录一些信息，加快匹配。</p><p><strong>KMP 算法永不回退 <code>txt</code> 的指针 <code>i</code>，不走回头路（不会重复扫描 <code>txt</code>），而是借助 <code>dp</code> 数组中储存的信息把 <code>pat</code> 移到正确的位置继续匹配</strong>，时间复杂度只需 O(N)，用空间换时间，所以可以看做是一种动态规划算法。</p><p>KMP算法的关键：如何计算<code>dp</code>数组中的信息，如何移动<code>pat</code>的指针。</p><p>&#x3D;&gt; 利用<u><strong>确定有限状态自动机</strong></u></p><hr><p>参考链接：</p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bebella.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="编程" scheme="https://www.bebella.cc/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://www.bebella.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【自然语言处理】三国演义分析</title>
    <link href="https://www.bebella.cc/2023/05/08/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%91%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E5%88%86%E6%9E%90/"/>
    <id>https://www.bebella.cc/2023/05/08/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E3%80%91%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89%E5%88%86%E6%9E%90/</id>
    <published>2023-05-08T11:15:28.000Z</published>
    <updated>2023-07-01T13:49:00.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-摘要（作业题目描述）"><a href="#1-摘要（作业题目描述）" class="headerlink" title="1. 摘要（作业题目描述）"></a>1. 摘要（作业题目描述）</h3><h3 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2. 算法分析"></a>2. 算法分析</h3><h4 id="2-1-出场人物频率"><a href="#2-1-出场人物频率" class="headerlink" title="2.1 出场人物频率"></a>2.1 出场人物频率</h4><p>a) 构建一个非人名集合，用于下面统计词频时排除不是人名的单词；<br>b) 对《三国演义》文本利用jieba包进行分词；<br>c) 定义一个字典去存储分词结果和出现的次数；<br>d) 在统计词频时，由于长度为1的单词大概率不是人名，因此忽略长度为1的词；<br>e) 同时，某些人物会具有多个名字，因此对这些人物的不同名字需要分开判断；<br>f) 把字典中一些不是人名的词语排除掉；<br>g) 根据字典的键值进行排序；<br>h) 最后格式化输出结果并通过matplotlib将结果可视化。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230508215142614.png" alt="image-20230508215142614"></p><h4 id="2-2-词频分析"><a href="#2-2-词频分析" class="headerlink" title="2.2  词频分析"></a>2.2  词频分析</h4><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230508223312492.png" alt="image-20230508223312492"></p><h4 id="2-3-人物关系网络的探索"><a href="#2-3-人物关系网络的探索" class="headerlink" title="2.3 人物关系网络的探索"></a>2.3 人物关系网络的探索</h4><h4 id="2-4-章节标题命名实体识别以及实体关系抽取"><a href="#2-4-章节标题命名实体识别以及实体关系抽取" class="headerlink" title="2.4 章节标题命名实体识别以及实体关系抽取"></a>2.4 章节标题命名实体识别以及实体关系抽取</h4><hr><p>参考资料：</p><ol><li><p>Python-人物词频统计-jieba库-三国演义</p><p><a href="https://blog.csdn.net/q1694222672/article/details/82014385">https://blog.csdn.net/q1694222672/article/details/82014385</a></p></li><li><p>python 绘制三国演义人物关系图</p><p><a href="https://blog.csdn.net/wei_zhen_dong/article/details/103586780">https://blog.csdn.net/wei_zhen_dong/article/details/103586780</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-摘要（作业题目描述）&quot;&gt;&lt;a href=&quot;#1-摘要（作业题目描述）&quot; class=&quot;headerlink&quot; title=&quot;1. 摘要（作业题目描述）&quot;&gt;&lt;/a&gt;1. 摘要（作业题目描述）&lt;/h3&gt;&lt;h3 id=&quot;2-算法分析&quot;&gt;&lt;a href=&quot;#2-算法分</summary>
      
    
    
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="python" scheme="https://www.bebella.cc/tags/python/"/>
    
    <category term="NLP" scheme="https://www.bebella.cc/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>【雅思】口语</title>
    <link href="https://www.bebella.cc/2023/05/05/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E5%8F%A3%E8%AF%AD/"/>
    <id>https://www.bebella.cc/2023/05/05/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E5%8F%A3%E8%AF%AD/</id>
    <published>2023-05-05T10:54:18.000Z</published>
    <updated>2023-07-01T13:48:16.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><h3 id="“do”，”did-“-”does”类问题"><a href="#“do”，”did-“-”does”类问题" class="headerlink" title="“do”，”did “,”does”类问题"></a>“do”，”did “,”does”类问题</h3><p>肯定回答：<br>Sure, absolutely<br>Oh, yeah, for sure<br>Yeah, I do actually<br>Sure, I can’t get enough of……</p><p>否定回答：<br>No, not for me<br>No, not at all<br>No, it’s not my favorite thing in the world<br>no, it’s not up my street actually</p><h3 id="雅思口语考试现场没听懂"><a href="#雅思口语考试现场没听懂" class="headerlink" title="雅思口语考试现场没听懂"></a>雅思口语考试现场没听懂</h3><p>I’m sorry, I didn’t follow&#x2F;catch it.  或者I didn’t get it.</p><p>Can you paraphrase&#x2F;rephrase it? </p><p>不要说Pardon</p><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><h2 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h2><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ol><li>声音要大、音调起伏</li><li>语速要慢：自信、稳重、流出时间思考</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;h2 id=&quot;Part-1&quot;&gt;&lt;a href=&quot;#Part-1&quot;</summary>
      
    
    
    
    <category term="英语" scheme="https://www.bebella.cc/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="雅思" scheme="https://www.bebella.cc/tags/%E9%9B%85%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>【雅思】 顾家北写作</title>
    <link href="https://www.bebella.cc/2023/04/08/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E9%A1%BE%E5%AE%B6%E5%8C%97%E5%86%99%E4%BD%9C/"/>
    <id>https://www.bebella.cc/2023/04/08/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E9%A1%BE%E5%AE%B6%E5%8C%97%E5%86%99%E4%BD%9C/</id>
    <published>2023-04-08T05:48:24.000Z</published>
    <updated>2023-07-01T13:48:08.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Task1"><a href="#Task1" class="headerlink" title="Task1"></a>Task1</h2><h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><h4 id="1-线图"><a href="#1-线图" class="headerlink" title="1. 线图"></a>1. 线图</h4><h4 id="2-线图，有预测值"><a href="#2-线图，有预测值" class="headerlink" title="2. 线图，有预测值"></a>2. 线图，有预测值</h4><p>不要加入揣测、建议，按照图上的说就行</p><ul><li>line graph 线图</li><li>throughout the period 贯穿整个时期</li><li>fluctuation(s) 可以有复数</li></ul><h4 id="3-饼图，百分比"><a href="#3-饼图，百分比" class="headerlink" title="3. 饼图，百分比"></a>3. 饼图，百分比</h4><ul><li><p>pie chart</p></li><li><p>present the finding of  a survey about ……</p></li><li><p>next consideration 次要考虑</p></li><li><p>different patterns were seen in the changes to the other n factors …. （段落衔接，表示：与前面不同的是）</p></li><li><p>fivefold 五倍 &#x3D;&gt; nfold n倍</p></li><li><p>triple 三倍</p></li><li><p>tertiary education 高等教育</p></li><li><p>access to the amenities and sports facilities 便利设施和体育设施</p></li></ul><h4 id="4-表格"><a href="#4-表格" class="headerlink" title="4. 表格"></a>4. 表格</h4><ul><li>table</li><li>provide information about …. 提供xxx的信息</li><li>rise 通常是好的提升</li><li>noticeably 显著的</li><li>worsening 坏的提升、恶化 adj.</li></ul><h4 id="5-amp-6-饼图，两组描述对象"><a href="#5-amp-6-饼图，两组描述对象" class="headerlink" title="5&amp;6. 饼图，两组描述对象"></a>5&amp;6. 饼图，两组描述对象</h4><ul><li>projected figures 预测的图</li><li>biggest one &#x2F; sector &#x2F; section&#x2F; slice of pie</li></ul><h4 id="7-柱状图，两组描述对象"><a href="#7-柱状图，两组描述对象" class="headerlink" title="7. 柱状图，两组描述对象"></a>7. 柱状图，两组描述对象</h4><ul><li>respectively</li></ul><h3 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h3><h4 id="1-柱状图"><a href="#1-柱状图" class="headerlink" title="1 柱状图"></a>1 柱状图</h4><ul><li>Similarly</li><li>around twice as high as the figure for women</li><li>xx gap</li><li>xx were favoured by a larger proportion of female students</li><li>the .. difference was less clear  区别不明显 &#x2F; 差别不大</li></ul><h4 id="2-饼图-多图"><a href="#2-饼图-多图" class="headerlink" title="2 饼图 + 多图"></a>2 饼图 + 多图</h4><ul><li>the chart and the table provide information on the main reasons for ……</li><li>xxx has the greatest impact on …, two other major causes are…</li></ul><h4 id="3-柱状图-多图"><a href="#3-柱状图-多图" class="headerlink" title="3 柱状图 + 多图"></a>3 柱状图 + 多图</h4><ul><li>the vast majority of …, compared with ….</li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Task1&quot;&gt;&lt;a href=&quot;#Task1&quot; class=&quot;headerlink&quot; title=&quot;Task1&quot;&gt;&lt;/a&gt;Task1&lt;/h2&gt;&lt;h3 id=&quot;动态图&quot;&gt;&lt;a href=&quot;#动态图&quot; class=&quot;headerlink&quot; title=&quot;动态图&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="英语" scheme="https://www.bebella.cc/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="雅思" scheme="https://www.bebella.cc/tags/%E9%9B%85%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>【专业课】数据结构</title>
    <link href="https://www.bebella.cc/2023/04/07/%E3%80%90%E4%B8%93%E4%B8%9A%E8%AF%BE%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.bebella.cc/2023/04/07/%E3%80%90%E4%B8%93%E4%B8%9A%E8%AF%BE%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-04-07T11:36:34.000Z</published>
    <updated>2023-04-07T11:55:46.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h2><h3 id="2-1-线性表类型定义"><a href="#2-1-线性表类型定义" class="headerlink" title="2.1  线性表类型定义"></a>2.1  线性表类型定义</h3><h3 id="2-2-线性表的顺序表示和实现"><a href="#2-2-线性表的顺序表示和实现" class="headerlink" title="2.2 线性表的顺序表示和实现"></a>2.2 线性表的顺序表示和实现</h3><h3 id="2-3-线性表的链式表示和实现"><a href="#2-3-线性表的链式表示和实现" class="headerlink" title="2.3 线性表的链式表示和实现"></a>2.3 线性表的链式表示和实现</h3><h3 id="2-4-一元多项式的表示及相加"><a href="#2-4-一元多项式的表示及相加" class="headerlink" title="2.4 一元多项式的表示及相加"></a>2.4 一元多项式的表示及相加</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第2章-线性表&quot;&gt;&lt;a href=&quot;#第2章-线性表&quot; class=&quot;headerlink&quot; title=&quot;第2章 线性表&quot;&gt;&lt;/a&gt;第2章 线性表&lt;/h2&gt;&lt;h3 id=&quot;2-1-线性表类型定义&quot;&gt;&lt;a href=&quot;#2-1-线性表类型定义&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="专业课" scheme="https://www.bebella.cc/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    <category term="数据结构" scheme="https://www.bebella.cc/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【雅思】刘洪波阅读</title>
    <link href="https://www.bebella.cc/2023/03/25/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E5%88%98%E6%B4%AA%E6%B3%A2%E9%98%85%E8%AF%BB/"/>
    <id>https://www.bebella.cc/2023/03/25/%E3%80%90%E9%9B%85%E6%80%9D%E3%80%91%E5%88%98%E6%B4%AA%E6%B3%A2%E9%98%85%E8%AF%BB/</id>
    <published>2023-03-25T11:57:09.000Z</published>
    <updated>2023-07-01T13:48:30.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Before-Class"><a href="#Before-Class" class="headerlink" title="Before Class"></a>Before Class</h2><ul><li>看文章最重要的一般是<strong>第二段和最后一段</strong></li></ul><h2 id="Lecture-1-总纲、单词题"><a href="#Lecture-1-总纲、单词题" class="headerlink" title="Lecture 1 总纲、单词题"></a>Lecture 1 总纲、单词题</h2><h3 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h3><ul><li>雅思阅读文章特点：要<strong>读得快</strong>，否则理解力会下降。<ul><li>扩大视距</li><li>变速：读的懂的慢，不懂的快速通过</li><li>跳读：重点读认识的，能理解的；不认识的跳过</li></ul></li></ul><h3 id="3类vocabulary"><a href="#3类vocabulary" class="headerlink" title="3类vocabulary"></a>3类vocabulary</h3><p>题干中：account, suggestopedia, resemble</p><p><strong>如何知道自己的词汇量是否达到7分最低标准：</strong>1-13题，看题干（包括选项），3个不认识的单词，说明达标</p><ul><li>文章的主题词：没关系（能猜出来</li><li>模板词：belike: reference, detail</li></ul><blockquote><p>这类词，不会的题干中的重要的词，记下来自己背</p></blockquote><ul><li>考点词：必背！eg: resemble</li></ul><h3 id="3类Keywords"><a href="#3类Keywords" class="headerlink" title="3类Keywords"></a>3类Keywords</h3><p>！警惕：看题、画keywords -&gt; 看文章 -&gt; 再看题选答案</p><ul><li>直接读两遍题目，画出keywords，再读原文找答案。读懂了题目再找答案。</li></ul><p>Heading题：段落中</p><p>keywords：</p><ul><li>眼球级：大写、数字</li><li>朴素级：最简单的词，和高级一点的匹配</li><li>逻辑关系词：并列、转折、因果<ul><li>题目中有逻辑词，原文中必有类似表达</li></ul></li></ul><h3 id="总纲标注法"><a href="#总纲标注法" class="headerlink" title="总纲标注法"></a>总纲标注法</h3><p>反对<strong>精读</strong>，强调<strong>快速、对比</strong>阅读</p><p>总纲标注法（对比阅读法）：画出所有题干和原文的同义词替换</p><p>一开始不用在意时间，先做对，再慢慢变快。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>以剑7, p18 为例</p><ol><li>看标题</li><li>看题型分布（匹配、summary、单词）【要知道每个题考的是是顺序还是伦旭】</li><li>精读匹配题目两遍，然后画keywords &#x3D;&gt; 接着看summary</li><li>summary看到blind，作为keywords读A，若A中无blind，说明A段只能是1-5题 &#x3D;&gt; 选一个匹配</li></ol><h2 id="Lecture-2-句子题"><a href="#Lecture-2-句子题" class="headerlink" title="Lecture 2 句子题"></a>Lecture 2 句子题</h2><p><strong>夹心饼干原则</strong>：</p><p>填空题：不是为了考察这个空，本质要注意空格前后 </p><p><strong>看不懂怎么办</strong>：</p><p>找keywords前后3行（前中后），不会的大概率是你看不懂的单词的同义词</p><p><strong>多选题：</strong></p><p>先读题，然后在文中找对应的部分，再细读找答案</p><p><strong>做题顺序：</strong></p><p>先细节题后大意题</p><h3 id="TFNG-x2F-Multiple-Choice："><a href="#TFNG-x2F-Multiple-Choice：" class="headerlink" title="TFNG &#x2F; Multiple Choice："></a>TFNG &#x2F; Multiple Choice：</h3><p>自看同义词替换</p><p><strong>True:</strong> </p><p>一般都是原文改写，注意原词替换</p><ul><li>针对一个句子true</li><li>针对上下文</li><li>针对上下文归纳出题（少见、难）</li></ul><p><strong>False：</strong></p><ul><li><p>出反义词</p></li><li><p>关系驳斥</p></li></ul><p><strong>Not Given：</strong></p><ul><li>题干信息不存在</li><li>题干中描述的关系不存在（有A有B但关系不对）</li></ul><h2 id="Lecture-3-段落题"><a href="#Lecture-3-段落题" class="headerlink" title="Lecture 3 段落题"></a>Lecture 3 段落题</h2><h2 id="Lecture-4-匹配题"><a href="#Lecture-4-匹配题" class="headerlink" title="Lecture 4 匹配题"></a>Lecture 4 匹配题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Before-Class&quot;&gt;&lt;a href=&quot;#Before-Class&quot; class=&quot;headerlink&quot; title=&quot;Before Class&quot;&gt;&lt;/a&gt;Before Class&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;看文章最重要的一般是&lt;strong&gt;第二段和最后</summary>
      
    
    
    
    <category term="英语" scheme="https://www.bebella.cc/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="雅思" scheme="https://www.bebella.cc/tags/%E9%9B%85%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>【算法】Acwing_算法基础(一)</title>
    <link href="https://www.bebella.cc/2023/03/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Acwing_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>https://www.bebella.cc/2023/03/06/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91Acwing_%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80(%E4%B8%80)/</id>
    <published>2023-03-06T08:56:26.000Z</published>
    <updated>2023-07-01T13:58:20.278Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="Acwing-791-高精度加法"><a href="#Acwing-791-高精度加法" class="headerlink" title="Acwing 791. 高精度加法"></a>Acwing 791. 高精度加法</h4><p>给定两个正整数（不含前导 00），计算它们的和。</p><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，每行包含一个整数。</p><h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含所求的和。</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤整数长度≤1000001≤整数长度≤100000</p><h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><ol><li>大整数的存储：用数组，倒着存。</li><li>用 <code>t</code> 存储进位。</li></ol><h5 id="Answer："><a href="#Answer：" class="headerlink" title="Answer："></a>Answer：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义加法方式</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line"><span class="comment">//        t&gt;10， 需要进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//  如果最后还需要进位</span></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 比较长，故用字符串表示</span></span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 a = &quot;123456&quot;</span></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// A = [6, 5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A , B);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    print， 因为是倒着存的，所以要倒着输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-792-高精度减法"><a href="#AcWing-792-高精度减法" class="headerlink" title="AcWing 792. 高精度减法"></a>AcWing 792. 高精度减法</h4><p>给定两个正整数（不含前导 00），计算它们的差，计算结果可能为负数。</p><h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，每行包含一个整数。</p><h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含所求的差。</p><h5 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤整数长度≤1051≤整数长度≤105</p><h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><ol><li>A - B， 默认A&gt;B</li><li>若A&lt;B， 加个负号</li><li>sub函数中，需要注意借位的使用</li></ol><h5 id="Answer：-1"><a href="#Answer：-1" class="headerlink" title="Answer："></a>Answer：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先比较位数</span></span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 比较大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">        &#123;</span><br><span class="line">            c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="comment">// 初始 t = 0</span></span><br><span class="line">        <span class="comment">// 此处先解决进位</span></span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) </span><br><span class="line">            t -= B[i];</span><br><span class="line">        <span class="comment">// t+10 防止借位后变成负数</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 如果借位了</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若结果00x 要去0</span></span><br><span class="line">    <span class="comment">// 去掉前导 0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        C.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 比较长，故用字符串表示</span></span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设 a = &quot;123456&quot;</span></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// A = [6, 5,4,3,2,1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-793-高精度乘法"><a href="#AcWing-793-高精度乘法" class="headerlink" title="AcWing 793. 高精度乘法"></a>AcWing 793. 高精度乘法</h4><p>给定两个非负整数（不含前导 00） AA 和 BB，请你计算 A×BA×B 的值。</p><h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p><h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 A×BA×B 的值。</p><h5 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤A的长度≤1000001≤A的长度≤100000,<br>0≤B≤100000≤B≤10000</p><h5 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h5 id="Answer：-2"><a href="#Answer：-2" class="headerlink" title="Answer："></a>Answer：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        <span class="comment">// 保留个位</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 保留进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要考虑前导0,若b = 0， 有可能出现前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-794-高精度除法"><a href="#AcWing-794-高精度除法" class="headerlink" title="AcWing 794. 高精度除法"></a>AcWing 794. 高精度除法</h4><p>给定两个非负整数（不含前导 0） A，BA，B，请你计算 A&#x2F;B的商和余数。</p><h5 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h5><p>共两行，第一行包含整数 A，第二行包含整数 B。</p><h5 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h5><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h5 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤A的长度≤100000,<br>1≤B≤100001≤B≤10000,<br>B 一定不为 0</p><h5 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="Answer"><a href="#Answer" class="headerlink" title="Answer:"></a>Answer:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A / b ... r</span></span><br><span class="line"><span class="comment">// r需要引用，因为有改变。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这个是 商</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 除法操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后还是倒着输出的</span></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 去掉前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">        A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><h4 id="AcWing-795-前缀和"><a href="#AcWing-795-前缀和" class="headerlink" title="AcWing  795. 前缀和"></a>AcWing  795. 前缀和</h4><p>输入一个长度为 n 的整数序列。</p><p>接下来再输入 mm 个询问，每个询问输入一对 l,r。</p><p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p><h5 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含两个整数 n 和 m。</p><p>第二行包含 n 个整数，表示整数数列。</p><p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p><h5 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 m 行，每行输出一个询问的结果。</p><h5 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000</p><h5 id="输入样例：-4"><a href="#输入样例：-4" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h5 id="输出样例：-4"><a href="#输出样例：-4" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h5 id="Answer：-3"><a href="#Answer：-3" class="headerlink" title="Answer："></a>Answer：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和的初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-796-子矩阵的和"><a href="#AcWing-796-子矩阵的和" class="headerlink" title="AcWing 796. 子矩阵的和"></a>AcWing 796. 子矩阵的和</h4><p>输入一个 nn 行 mm 列的整数矩阵，再输入 qq 个询问，每个询问包含四个整数 x1,y1,x2,y2x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p><h5 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含三个整数 n，m，qn，m，q。</p><p>接下来 nn 行，每行包含 mm 个整数，表示整数矩阵。</p><p>接下来 qq 行，每行包含四个整数 x1,y1,x2,y2x1,y1,x2,y2，表示一组询问。</p><h5 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h5><p>共 qq 行，每行输出一个询问的结果。</p><h5 id="数据范围-5"><a href="#数据范围-5" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤n,m≤10001≤n,m≤1000,<br>1≤q≤2000001≤q≤200000,<br>1≤x1≤x2≤n1≤x1≤x2≤n,<br>1≤y1≤y2≤m1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000</p><h5 id="输入样例：-5"><a href="#输入样例：-5" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure><h5 id="输出样例：-5"><a href="#输出样例：-5" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure><h5 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h5><h5 id="Answer：-4"><a href="#Answer：-4" class="headerlink" title="Answer："></a>Answer：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d,&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算二维版的“前缀和”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="AcWing-799-最长连续不重复子序列"><a href="#AcWing-799-最长连续不重复子序列" class="headerlink" title="AcWing 799. 最长连续不重复子序列"></a>AcWing 799. 最长连续不重复子序列</h4><h4 id="AcWing-800-数组元素的目标和"><a href="#AcWing-800-数组元素的目标和" class="headerlink" title="AcWing 800. 数组元素的目标和"></a>AcWing 800. 数组元素的目标和</h4><p>给定：升序数组A[] B[]， 目标值x</p><p>要求：A[i] + B[j] &#x3D; x 的数对 (i, j)</p><h5 id="暴力：-TLE"><a href="#暴力：-TLE" class="headerlink" title="暴力：(TLE)"></a>暴力：(TLE)</h5><p>遍历A、B，当A[i] &lt; x 的时候，寻找B[j]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process</span></span><br><span class="line">    <span class="type">int</span> resi = <span class="number">0</span>, resj = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (B[j] &lt;= x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[i] + B[j] == x)</span><br><span class="line">                    &#123;</span><br><span class="line">                        resi = i;</span><br><span class="line">                        resj = j;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; resi &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; resj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双指针-Accepted"><a href="#双指针-Accepted" class="headerlink" title="双指针 Accepted"></a>双指针 Accepted</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, x;</span><br><span class="line"><span class="type">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process</span></span><br><span class="line">     <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[i] + B [j] &gt; x) j --;</span><br><span class="line">        <span class="keyword">if</span> (A[i] + B[j] == x) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; resi &lt;&lt; &quot; &quot; &lt;&lt; resj;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing2816-判断子序列"><a href="#AcWing2816-判断子序列" class="headerlink" title="AcWing2816. 判断子序列"></a>AcWing2816. 判断子序列</h4><p>要求：判断a[] 是否是b[] 的子序列</p><p>子序列指序列的一部分项按<strong>原有次序排列</strong>而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5}的一个子序列。</p><p>WA：</p><p>错误的思路：</p><ol><li><p>开个数组c[i] 记录匹配情况，初始化为0，随后判断c[i]中是否全为1，如果是就输出yes</p></li><li><p>存在问题：无法按顺序判断子序列</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line"></span><br><span class="line">My Answer: Yes</span><br><span class="line">Standard Answer: No </span><br><span class="line">此方法仅考虑存在性而没有考虑顺序。</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process</span></span><br><span class="line">    <span class="comment">// 开一个c[]存结果</span></span><br><span class="line">    <span class="type">int</span> c[n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j])&#123;</span><br><span class="line">                c[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双指针AC</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// input</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process</span></span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) i ++;</span><br><span class="line">        j ++;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (i == n) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><p>离散化的本质是建立了一段数列到自然数之间的映射关系（value -&gt; index)，将<code>自然数key</code>映射为它在<code>数组中的索引index</code>，通过建立新索引，来缩小目标区间，使得可以进行一系列连续数组可以进行的操作比如二分，前缀和等…</p><p>离散化首先要排序去重：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 排序： <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>())</span><br><span class="line"><span class="number">2.</span> 去重： alls.<span class="built_in">earse</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>unique()原理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::<span class="function">iterator <span class="title">unique</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="comment">// 1. 第一个元素</span></span><br><span class="line">        <span class="comment">// 2. 该元素不等于前一个元素</span></span><br><span class="line">        <span class="comment">// 满足1 or 2的存入数组里</span></span><br><span class="line">        <span class="keyword">if</span> ( !i || a[i] != a[i - <span class="number">1</span>])</span><br><span class="line">            a[j ++] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前 j 个不重复元素的下标</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">begin</span>() + j;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="AcWing802-区间和"><a href="#AcWing802-区间和" class="headerlink" title="AcWing802_区间和"></a>AcWing802_区间和</h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 cc。</p><p>接下来，进行 mm 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><p>输入格式</p><p>第一行包含两个整数 n 和 m。</p><p>接下来 n 行，每行包含两个整数 x 和 c。</p><p>再接下来 m 行，每行包含两个整数 l 和 r。</p><p>输出格式</p><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><p>数据范围</p><p>−109≤x≤109,<br>1≤n,m≤105,<br>−109≤l≤r≤109,<br>−10000≤c≤10000</p><p>输入样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>由于本题可能有多组数据是针对同一个数组下标操作的，因此我们可以将所有用到的数组下标装在一个下标容器<code>alls</code>内去重，然后再逐一为相同的数组下标增加数值c，再通过对应前缀和相减求得区间<code>l~r</code>之间的数的值</p><p><code>const int N = 300010</code> &#x3D;&gt;  n + 2m 最大可能值</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;  <span class="comment">//存入下标容器</span></span><br><span class="line">vector&lt;PII&gt; add, query;  <span class="comment">//add增加容器，存入对应下标和增加的值的大小</span></span><br><span class="line"><span class="comment">//query存入需要计算下标区间和的容器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//查找大于等于x的最小的值的下标</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为使用前缀和，其下标要+1可以不考虑边界问题</span></span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);<span class="comment">//存入下标即对应的数值c</span></span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);<span class="comment">//存入数组下标x=add.first</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);<span class="comment">//存入要求的区间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入区间左右下标</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);<span class="comment">//将add容器的add.secend值存入数组a[]当中，</span></span><br><span class="line">        a[x] += item.second;<span class="comment">//在去重之后的下标集合alls内寻找对应的下标并添加数值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);<span class="comment">//在下标容器中查找对应的左右两端[l~r]下标，然后通过下标得到前缀和相减再得到区间a[l~r]的和</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><p>有交集的区间合并为一个区间，返回合并之后的区间个数</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>两个区间a, b的关系：</p><ol><li>在内部</li><li>有交集</li><li>边界重合</li><li>没有共同部分</li></ol><p>处理过程：</p><ol><li>按区间左端点排序</li><li>初始化start, end 为负无穷</li><li>区间有重合部分合并：左端点不变，更新右端点。</li><li></li></ol><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定 n 个区间 $[l_i,r_i]$，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1,3] 和 [2,6] 可以合并为一个区间 [1, 6]。</p><h4 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含两个整数 l 和 r。</p><h4 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示合并区间完成后的区间个数。</p><h4 id="数据范围-6"><a href="#数据范围-6" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤100000,<br>−109≤$l_i$≤$r_i$≤109</p><h4 id="输入样例：-6"><a href="#输入样例：-6" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;5</span><br><span class="line">&gt;1 2</span><br><span class="line">&gt;2 4</span><br><span class="line">&gt;5 6</span><br><span class="line">&gt;7 8</span><br><span class="line">&gt;7 9</span><br></pre></td></tr></table></figure><h4 id="输出样例：-6"><a href="#输出样例：-6" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;3</span><br></pre></td></tr></table></figure></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());  <span class="comment">// 按照左端点排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设初始都为无穷小</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)&#123; <span class="comment">// 情况1：在内部</span></span><br><span class="line">            <span class="keyword">if</span> (ed != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">// 若ed非负无穷，可更新区间。</span></span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); <span class="comment">// 情况2：仅仅是有交集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 情况3：没有重合的位置，会更新到下一个st中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特判最后一个区间</span></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;高精度&quot;&gt;&lt;a href=&quot;#高精度&quot; class=&quot;headerlink&quot; title=&quot;高精度&quot;&gt;&lt;/a&gt;高精度&lt;/h3&gt;&lt;h4 id=&quot;Acwing-791-高精度加法&quot;&gt;&lt;a href=&quot;#Acwing-791-高精度加法&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="算法" scheme="https://www.bebella.cc/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="编程" scheme="https://www.bebella.cc/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="AcWing" scheme="https://www.bebella.cc/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>计算机英语期末</title>
    <link href="https://www.bebella.cc/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD%E6%9C%9F%E6%9C%AB/"/>
    <id>https://www.bebella.cc/2022/12/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD%E6%9C%9F%E6%9C%AB/</id>
    <published>2022-12-19T10:32:56.000Z</published>
    <updated>2023-07-01T13:51:20.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="week-02"><a href="#week-02" class="headerlink" title="week 02"></a>week 02</h1><p>IT: information technology</p><p>the use of computer and software to manage information.</p><p>prefix:</p><ul><li>multimedia</li><li>minibus</li><li>superhero</li><li>internet</li><li>microsoft</li></ul><p>It department has Chief Information Officer (CIO)</p><p>It department should be responsible for:</p><ul><li>storing information</li><li>protecting information</li><li>processing information</li><li>transmitting information</li><li>retrieving information</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;week-02&quot;&gt;&lt;a href=&quot;#week-02&quot; class=&quot;headerlink&quot; title=&quot;week 02&quot;&gt;&lt;/a&gt;week 02&lt;/h1&gt;&lt;p&gt;IT: information technology&lt;/p&gt;
&lt;p&gt;the use of compu</summary>
      
    
    
    
    <category term="英语" scheme="https://www.bebella.cc/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%8B%B1%E8%AF%AD/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>【spring】（11）注解</title>
    <link href="https://www.bebella.cc/2022/11/24/%E3%80%90spring%E3%80%91%EF%BC%8811%EF%BC%89%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.bebella.cc/2022/11/24/%E3%80%90spring%E3%80%91%EF%BC%8811%EF%BC%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-11-24T05:06:16.000Z</published>
    <updated>2023-03-05T07:52:01.062Z</updated>
    
    <content type="html"><![CDATA[<p>Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><h2 id="1-IOC-x2F-DI注解开发"><a href="#1-IOC-x2F-DI注解开发" class="headerlink" title="1. IOC&#x2F;DI注解开发"></a>1. IOC&#x2F;DI注解开发</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><ul><li>创建一个maven</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Spring对注解支持的版本历程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.0版开始支持注解&lt;/li&gt;
&lt;li&gt;2.5版注解功能趋于完善&lt;/li&gt;
&lt;li&gt;3.0版支持纯注解开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-IOC-x2F-DI注解开发&quot;&gt;&lt;a href=&quot;#1-IOC</summary>
      
    
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="后端" scheme="https://www.bebella.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】（10）容器</title>
    <link href="https://www.bebella.cc/2022/11/23/%E3%80%90Spring%E3%80%91%EF%BC%8810%EF%BC%89%E5%AE%B9%E5%99%A8/"/>
    <id>https://www.bebella.cc/2022/11/23/%E3%80%90Spring%E3%80%91%EF%BC%8810%EF%BC%89%E5%AE%B9%E5%99%A8/</id>
    <published>2022-11-23T08:54:26.000Z</published>
    <updated>2023-03-05T07:56:24.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="10-容器"><a href="#10-容器" class="headerlink" title="10. 容器"></a>10. 容器</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><h5 id="方式一：加载类路径下的配置文件（常用）"><a href="#方式一：加载类路径下的配置文件（常用）" class="headerlink" title="方式一：加载类路径下的配置文件（常用）"></a>方式一：加载类路径下的配置文件（常用）</h5><p>关键<code>ClassPathXmlAppliactionContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="方式二：文件系统下加载配置文件"><a href="#方式二：文件系统下加载配置文件" class="headerlink" title="方式二：文件系统下加载配置文件"></a>方式二：文件系统下加载配置文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;AbsolutePath&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="方式三：加载多个配置文件"><a href="#方式三：加载多个配置文件" class="headerlink" title="方式三：加载多个配置文件"></a>方式三：加载多个配置文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;file1.xml&quot;,&quot;file2.xml&quot;);</span><br></pre></td></tr></table></figure><h4 id="获取bean"><a href="#获取bean" class="headerlink" title="获取bean"></a>获取bean</h4><h5 id="方式一：使用bean名称"><a href="#方式一：使用bean名称" class="headerlink" title="方式一：使用bean名称"></a>方式一：使用bean名称</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="方式二：使用bean名称并且指定类型"><a href="#方式二：使用bean名称并且指定类型" class="headerlink" title="方式二：使用bean名称并且指定类型"></a>方式二：使用bean名称并且指定类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure><h5 id="方式三：使用bean类型获取"><a href="#方式三：使用bean类型获取" class="headerlink" title="方式三：使用bean类型获取"></a>方式三：使用bean类型获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(BookDao.class)</span><br></pre></td></tr></table></figure><p>这种方式要求容器中bean只能有一个</p><h4 id="容器总结"><a href="#容器总结" class="headerlink" title="容器总结"></a>容器总结</h4><h5 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h5><ul><li><code>BeanFactory</code>是IoC容器顶层接口，初始化<code>BeanFactory</code>对象时，加载的bean延迟加载</li><li><code>ApplicationContext</code>接口是Spring容器的核心接口，初始化时bean立即加载</li><li><code>ApplicationContext</code>接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li><code>ApplicationContext</code>接口常用初始化类 :<ul><li><code>ClassPathXmlApplicationContext</code>(常用) </li><li><code>FileSystemXmlApplicationContext</code></li></ul></li></ul><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h8f6f5gt9lj20po0anjwn.jpg"></p><h5 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h5><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h8f6fsg42uj20qg0c3tfa.jpg"></p><h3 id="11-注解开发"><a href="#11-注解开发" class="headerlink" title="11. 注解开发"></a>11. 注解开发</h3><p><code>@Component(&quot;bean.id&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.xml配置</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;10-容器&quot;&gt;&lt;a href=&quot;#10-容器&quot; class=&quot;headerlink&quot; title=&quot;10. 容器&quot;&gt;&lt;/a&gt;10. 容器&lt;/h3&gt;&lt;h4 id=&quot;创建容器&quot;&gt;&lt;a href=&quot;#创建容器&quot; class=&quot;headerlink&quot; title=&quot;创建容</summary>
      
    
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="后端" scheme="https://www.bebella.cc/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SSM系列（一）------ Spring</title>
    <link href="https://www.bebella.cc/2022/11/18/%E6%A1%86%E6%9E%B6/"/>
    <id>https://www.bebella.cc/2022/11/18/%E6%A1%86%E6%9E%B6/</id>
    <published>2022-11-18T12:15:12.000Z</published>
    <updated>2022-11-20T12:38:53.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><h3 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h3><ul><li><p>官网：<a href="https://spring.io/">spring.io</a></p></li><li><p>全家桶</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h89k58ohk7j20hj05r76m.jpg" alt="Spring全家桶"></p><blockquote><p>核心要学习的：</p><p>Spring Framework</p><p>Spring Boot</p><p>Spring Cloud</p></blockquote></li></ul><h3 id="Spring-发展史"><a href="#Spring-发展史" class="headerlink" title="Spring 发展史"></a>Spring 发展史</h3><p>现在是5.0版本</p><h3 id="Spring-Framework系统架构"><a href="#Spring-Framework系统架构" class="headerlink" title="Spring  Framework系统架构"></a>Spring  Framework系统架构</h3><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h89kf2wywzj20nl0g579m.jpg" alt="Spring  Framework系统架构"></p><ul><li>Data Access 数据访问</li><li>Data Integration 数据集成</li><li>Web Web开发</li><li>AOP 面向切面编程</li><li>Aspects AOP思想实现</li><li>Core Container 核心容器</li><li>Test 单元测试与集成测试</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="IoC-x2F-DI（Inversion-of-Control）"><a href="#IoC-x2F-DI（Inversion-of-Control）" class="headerlink" title="IoC&#x2F;DI（Inversion of Control）"></a>IoC&#x2F;DI（Inversion of Control）</h4><ul><li>使用对象时，主动new &#x3D;&gt; 外部提供对象</li><li>对象创建控制权由程序转移到外部 &#x3D;&gt; 控制反转思想</li></ul><h4 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h4><ul><li>Spring提供了一个容器：IoC容器，充当IoC思想中的“外部”</li><li>IoC容器负责对象的创建、初始化等一系列工作</li></ul><h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h4><ul><li>被创建or管理的对象在IoC中统称为Bean</li></ul><h4 id="目标：充分解耦"><a href="#目标：充分解耦" class="headerlink" title="目标：充分解耦"></a>目标：充分解耦</h4><ul><li>使用IoC容器管理bean</li><li>在IoC容器内将有依赖关系的bean进行关系绑定（DI）</li></ul><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><ul><li>适用对象的时候不尽快与直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系</li></ul><h3 id="bean配置"><a href="#bean配置" class="headerlink" title="bean配置"></a>bean配置</h3><ul><li>bean默认为单例：节省空间</li><li>适合交给容器管理的bean<ul><li>表现层对象 server</li><li>业务层对象 service</li><li>数据层对象 dao</li><li>工具类对象</li></ul></li><li>不适合交给容器管理的bean<ul><li>封装实体的域对象</li></ul></li></ul><h3 id="bean生命周期"><a href="#bean生命周期" class="headerlink" title="bean生命周期"></a>bean生命周期</h3><ul><li>初始化容器<ol><li>创建对象（内存分配）</li><li>执行构造方法</li><li>执行属性注入（set）</li><li>执行bean初始化方法</li></ol></li><li>使用bean<ul><li>执行业务操作</li></ul></li><li>关闭or销毁容器<ul><li>执行bean销毁方法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Spring简介&quot;&gt;&lt;a href=&quot;#一、Spring简介&quot; class=&quot;headerlink&quot; title=&quot;一、Spring简介&quot;&gt;&lt;/a&gt;一、Spring简介&lt;/h2&gt;&lt;h3 id=&quot;初识Spring&quot;&gt;&lt;a href=&quot;#初识Spring&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【自然语言处理NLP】（10）语义分析</title>
    <link href="https://www.bebella.cc/2022/11/14/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86NLP%E3%80%91%EF%BC%8810%EF%BC%89%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/"/>
    <id>https://www.bebella.cc/2022/11/14/%E3%80%90%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86NLP%E3%80%91%EF%BC%8810%EF%BC%89%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</id>
    <published>2022-11-14T07:24:20.000Z</published>
    <updated>2023-07-01T13:49:07.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h3 id="词汇级"><a href="#词汇级" class="headerlink" title="词汇级"></a>词汇级</h3><h4 id="词义消歧"><a href="#词义消歧" class="headerlink" title="词义消歧"></a>词义消歧</h4><p>自然语言处理中的基本问题之一，在机器翻译、文本分类、信息检索、语音识别、语义网络构建等方面都具有重要意义</p><p>自然语言中一个词具有多种含义的现象非常普遍。如何自动获悉某个词的多种含义；或者已知某个词有多种含义，如何根据上下文确认其含义，是词义消歧研究的内容。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h84ot6n8f1j20h80aqgr6.jpg" alt="打的多样性"></p><p>分为四类方法：</p><h5 id="1-基于背景知识的语义消歧（基于规则的方法）"><a href="#1-基于背景知识的语义消歧（基于规则的方法）" class="headerlink" title="1. 基于背景知识的语义消歧（基于规则的方法）"></a>1. 基于背景知识的语义消歧（基于规则的方法）</h5><p>基于背景知识的语义消歧方法基本思想是这样的：通过词典中词条本身的定义作为判断其语义的条件。<br>举个例子，cone这个词在词典中有两个定义：一个是指“松树的球果”，另一个是指“用于盛放其他东西的锥形物，比如，盛放冰激凌的锥形薄饼”。<br>如果在文本中，“树(tree)”或者“冰(ice)”与cone出现在相同的上下文中，那么，cone的语义就可以确定了，tree对应cone的语义1，ice对应cone的语义2。<br>可以看出，这种方法完全是基于规则的。</p><h5 id="2-监督的语义消歧方法"><a href="#2-监督的语义消歧方法" class="headerlink" title="2. 监督的语义消歧方法"></a>2. 监督的语义消歧方法</h5><p>监督学习的方法就是，数据的类别在学习之前已经知道。<br>在语义消歧的问题上，每个词所有可能的义项都是已知的。有监督的语义消歧方法是通过一个已标注的语料库学习得到一个分类模型。</p><p>常用方法：</p><ol><li><h6 id="基于贝叶斯分类器的词义消歧方法"><a href="#基于贝叶斯分类器的词义消歧方法" class="headerlink" title="基于贝叶斯分类器的词义消歧方法"></a>基于<strong>贝叶斯分类器</strong>的词义消歧方法</h6></li><li><p>基于<strong>最大熵</strong>的词义消歧方法</p><p>每个词表达不同含意时其上下文（语境）往往不同，即不同的词义对应不同的上下文。因此，可以将词的上下文作为特征信息利用最大熵模型对词的语义进行分类。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h84p5cgp9oj20lk0e5q84.jpg" alt="image.png"><img src="https://img-blog.csdnimg.cn/20190919205143646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2VjaG9LYW5nWUw=,size_16,color_FFFFFF,t_70" alt="最大熵模型语义消歧2"></p></li><li><p>基于<strong>互信息</strong>的消歧方法</p></li></ol><h5 id="3-半监督的学习方法"><a href="#3-半监督的学习方法" class="headerlink" title="3.半监督的学习方法"></a>3.半监督的学习方法</h5><h5 id="4-无监督的学习方法"><a href="#4-无监督的学习方法" class="headerlink" title="4. 无监督的学习方法"></a>4. 无监督的学习方法</h5><h4 id="词语相似度"><a href="#词语相似度" class="headerlink" title="词语相似度"></a>词语相似度</h4><p>在信息检索、信息抽取、词义排歧、机器翻译、句法分析等处理中有很重要的作用。</p><p>两个词语在不同的上下文中可以互相替换使用而不改变文本的句法语义结构的程度。<br>在不同的上下文中可以互相替换且不改变文本句法语义结构的可能性越大，二者的相似度就越高，否则相似度就越低。</p><p>相似度以一个数值表示，一般取值范围在[0,1]之间。一个词语与其本身的语义相似度为1；如果两个词语在任何上下文中都不可替换，那么其相似度为0。<br>值得注意的是，相似度涉及到词语的词法、句法、语义甚至语用等方面的特点。其中，对词语相似度影响最大的应该是词的语义。</p><h6 id="词语距离"><a href="#词语距离" class="headerlink" title="词语距离"></a>词语距离</h6><p>词语距离是度量两个词语关系的另一个重要指标，用一个[0,∞)之间的实数表示。</p><p>大家可以想象，词语距离和词语相似度之间一定是存在某种关系的：</p><ol><li>两个词语距离为0时，其相似度为1 。即，一个词语与其本身的距离为0；</li><li>两个词语距离为无穷大时，其相似度为0；</li><li>两个词语的距离越大，其相似度越小（单调下降）。</li><li>如果将词语相似度记为$sim(w_1,w_2)$,而将词语距离记为$dis(w_1,w_2)$，则有：$sim(w_1,w_2)&#x3D;\frac{\alpha}{dis(w_1,w_2)+\alpha}$</li></ol><p>其中，$\alpha$是一个可调节的参数，表示<strong>相似度为0.5时的词语距离值</strong>（上式简单移项带入值既可）。</p><p>词语距离是为了当直接计算词语的相似度比较困难时，可以先计算词语距离，再转换成词语的相似度。</p><h6 id="词语相关性"><a href="#词语相关性" class="headerlink" title="词语相关性"></a>词语相关性</h6><p>词语相关性反映的是两个词语互相关联的程度，可以用这两个词语在同一个语境中共现的可能性来衡量。<br>一开始看见整个概念的时候可能会有种“这和词语相似度不是差不多么”这样的感觉，其实不然。<br>举个例子，“医生”和“疾病”这两个词之间的相似度很低，但是相关性很高（因为这两个词经常在同一语境中出现）。<br>用一句高深的话来讲，词语相似性反映的是词语之间的聚合特点，而词语相关性反映的是词语之间的组合特点。<br>词语相关性也以一个数值表示，一般取范围在[0,1]之间的实数。<br>虽然相关性与相似性并不相同，但实际上，词语相关性和词语相似性有着密切的联系。如果两个词语非常相似，那么这两个词语与其他词语的相关性也会非常接近。反之，如果两个词语与其他词语的相关性特点很接近，那么这两个词一般相似程度也很高。</p><h3 id="句子级"><a href="#句子级" class="headerlink" title="句子级"></a>句子级</h3><hr><p>参考：</p><p><a href="https://blog.csdn.net/echoKangYL/article/details/101034566?spm=1001.2014.3001.5502">https://blog.csdn.net/echoKangYL/article/details/101034566?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语义分析&quot;&gt;&lt;a href=&quot;#语义分析&quot; class=&quot;headerlink&quot; title=&quot;语义分析&quot;&gt;&lt;/a&gt;语义分析&lt;/h2&gt;&lt;h3 id=&quot;词汇级&quot;&gt;&lt;a href=&quot;#词汇级&quot; class=&quot;headerlink&quot; title=&quot;词汇级&quot;&gt;&lt;/a&gt;词汇</summary>
      
    
    
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="python" scheme="https://www.bebella.cc/tags/python/"/>
    
    <category term="NLP" scheme="https://www.bebella.cc/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>【软工实践】Spring MVC</title>
    <link href="https://www.bebella.cc/2022/11/12/%E3%80%90%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5%E3%80%91Spring-MVC/"/>
    <id>https://www.bebella.cc/2022/11/12/%E3%80%90%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5%E3%80%91Spring-MVC/</id>
    <published>2022-11-12T06:26:45.000Z</published>
    <updated>2022-11-12T06:26:45.445Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>【软件测试】实验一：Junit的使用</title>
    <link href="https://www.bebella.cc/2022/11/09/%E3%80%90%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E3%80%91%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9AJunit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.bebella.cc/2022/11/09/%E3%80%90%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E3%80%91%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9AJunit%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-11-09T03:13:51.000Z</published>
    <updated>2023-07-01T13:49:48.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Junit测试步骤"><a href="#一、Junit测试步骤" class="headerlink" title="一、Junit测试步骤"></a>一、Junit测试步骤</h2><h3 id="1-创建测试类"><a href="#1-创建测试类" class="headerlink" title="1. 创建测试类"></a>1. 创建测试类</h3><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7ypocm2sfj20oc0ijgpb.jpg" alt="测试类"></p><h3 id="2-设计测试用例"><a href="#2-设计测试用例" class="headerlink" title="2. 设计测试用例"></a>2. 设计测试用例</h3><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7ypowmedfj20f604cwge.jpg" alt="设计测试用例"></p><p>输入说明：</p><p>action：行为动作，取值为：存、取、显示</p><p>money：现有的存款</p><p>money_use：需要进行操作（存或取）的数量</p><h3 id="3-编写测试脚本"><a href="#3-编写测试脚本" class="headerlink" title="3. 编写测试脚本"></a>3. 编写测试脚本</h3><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7yppm8rk0j20ju0jcdms.jpg" alt="部分测试脚本展示"></p><h3 id="4-测试UserAccount类"><a href="#4-测试UserAccount类" class="headerlink" title="4. 测试UserAccount类"></a>4. 测试UserAccount类</h3><p>测试样例1</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221109113008198.png" alt="测试样例1"></p><p>测试样例2</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7yq9bvflfj20nu0d2tds.jpg" alt="测试样例2"></p><p>测试样例3</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7yqa9ejd3j20mx0hiwkc.jpg" alt="测试样例3"></p><p>测试样例4</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7yqbe5dluj20qd0g0q9l.jpg" alt="测试样例4"></p><p>测试样例5</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7yqccvc6sj20js0f9n1w.jpg" alt="测试样例5"></p><h2 id="二、测试方案优缺点评判"><a href="#二、测试方案优缺点评判" class="headerlink" title="二、测试方案优缺点评判"></a>二、测试方案优缺点评判</h2><h3 id="1-四种测试方案"><a href="#1-四种测试方案" class="headerlink" title="1. 四种测试方案"></a>1. 四种测试方案</h3><p>优点：</p><ul><li>支持多线程</li><li>简单直观</li></ul><p>缺点：</p><ul><li>对多个方法调用。 需要添加打印或者输出语句。 </li><li>添加了新的测试方法。 需要在main方法添加方法调用。 </li><li>不能形成整体的测试结果。</li><li>需要对打印或者输出结果进行人为的判断。</li><li>速度慢</li></ul><h3 id="2-Junit"><a href="#2-Junit" class="headerlink" title="2. Junit"></a>2. Junit</h3><p>优点：</p><ul><li>可以书写一系列的 测试方法，对项目所有的 接口或者方法进行单元测试。</li><li>启动后，自动化测试，并判断执行结果, 不需要人为的干预。</li><li>只需要查看最后结果，就知道整个项目的方法接口是否通畅。</li><li>每个单元测试用例相对独立， 由Junit 启动，自动调用。 不需要添加额外的调用语句。</li><li>添加，删除，屏蔽测试方法，不影响其他的测试方法。 开源框架都对JUnit 有相应的支持。</li><li>测试速度快</li></ul><p>缺点：</p><ul><li>不支持多线程</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Junit测试步骤&quot;&gt;&lt;a href=&quot;#一、Junit测试步骤&quot; class=&quot;headerlink&quot; title=&quot;一、Junit测试步骤&quot;&gt;&lt;/a&gt;一、Junit测试步骤&lt;/h2&gt;&lt;h3 id=&quot;1-创建测试类&quot;&gt;&lt;a href=&quot;#1-创建测试类&quot; c</summary>
      
    
    
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis_Docker下分片集群搭建</title>
    <link href="https://www.bebella.cc/2022/10/25/Redis-Docker%E4%B8%8B%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.bebella.cc/2022/10/25/Redis-Docker%E4%B8%8B%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2022-10-25T02:27:34.000Z</published>
    <updated>2022-10-25T03:07:50.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cluster分片集群"><a href="#Cluster分片集群" class="headerlink" title="Cluster分片集群"></a>Cluster分片集群</h2><h3 id="哨兵模式存在的问题"><a href="#哨兵模式存在的问题" class="headerlink" title="哨兵模式存在的问题"></a>哨兵模式存在的问题</h3><p>redis哨兵模式虽然提供了redis⾼可⽤、高并发读的解决方案，但是在海量数据应用场景下，仍然存在海量数据存储问题和高并发写的问题。当只有⼀个Master对外提供服务时，如果数据量特别⼤，内存占⽤问题严重，数据的高并发写、数据备份和恢复都会⼤⼤降低效率。</p><h3 id="Cluster集群的结构与作用"><a href="#Cluster集群的结构与作用" class="headerlink" title="Cluster集群的结构与作用"></a>Cluster集群的结构与作用</h3><h4 id="结构特点："><a href="#结构特点：" class="headerlink" title="结构特点："></a>结构特点：</h4><ul><li>Redis Cluster采用的是基于P2P的<strong>去中心化</strong>的网络拓扑架构，没有中心节点，所有节点<strong>既是数据存储节点，也是控制节点</strong>；</li><li>引入槽(slot)的概念，通过CRC+hashslot算法支持多个主节（分片），每个主节点分别负责存储一部分数据，这样理论上可以支持无限主节点的水平扩容以便支持海量吞吐量；</li><li>内置类似哨兵的高可用机制，能够实现自动故障转移，保证每个主节点的高可用。</li></ul><p>Cluster又称分片集群，拥有分片存储的特性，不需要哨兵也可以完成故障转移功能，具有高可用性，性能优于哨兵模式，可以实现四栋扩容（不建议超过1000个节点）</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ol><li>集群中有多个master，每个master保存不同数据；</li><li>每个master都可以有多个slave节点；</li><li>master之间通过ping监测彼此健康状态；</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</li></ol><p>数据和slot绑定，而不是和节点绑定</p><table><thead><tr><th>各节点容器外IP</th><th>各节点容器内IP</th></tr></thead><tbody><tr><td>主节点1:127.0.0.16379</td><td>Redis_6379:172.17.0.2:6379</td></tr><tr><td>主节点2:127.0.0.16380</td><td>Redis_6380:172.17.0.3:6379</td></tr><tr><td>主节点3:127.0.0.16381</td><td>Redis_6380:172.17.0.7:6379</td></tr><tr><td>从节点4:127.0.0.126379</td><td>Redis_26379:172.17.0.4:26379</td></tr><tr><td>从节点5:127.0.0.126380</td><td>Redis_6379:172.17.0.5:26380</td></tr><tr><td>从节点6:127.0.0.126380</td><td>Redis_6379:172.17.0.6:26381</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cluster分片集群&quot;&gt;&lt;a href=&quot;#Cluster分片集群&quot; class=&quot;headerlink&quot; title=&quot;Cluster分片集群&quot;&gt;&lt;/a&gt;Cluster分片集群&lt;/h2&gt;&lt;h3 id=&quot;哨兵模式存在的问题&quot;&gt;&lt;a href=&quot;#哨兵模式存在的问</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="https://www.bebella.cc/2022/10/23/MyBatis/"/>
    <id>https://www.bebella.cc/2022/10/23/MyBatis/</id>
    <published>2022-10-23T07:09:30.000Z</published>
    <updated>2022-10-23T10:38:44.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="从XML中构建SqlSessionFactory"><a href="#从XML中构建SqlSessionFactory" class="headerlink" title="从XML中构建SqlSessionFactory"></a>从XML中构建SqlSessionFactory</h3><ul><li>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。</li><li>SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</li></ul><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨 XML 配置文件的详细内容，这里先给出一个简单的示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    // environment元素体中包含了事务管理and连接池的配置</span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    // mapperrs包含了一组映射器mapper</span><br><span class="line">    // 这些映射器的xml映射文件包含了SQL代码和映射定义信息</span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="不使用xml构建SQLSessionFactory"><a href="#不使用xml构建SQLSessionFactory" class="headerlink" title="不使用xml构建SQLSessionFactory"></a>不使用xml构建SQLSessionFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTransactionFactory</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line"><span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(environment);</span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(configuration);</span><br></pre></td></tr></table></figure><p>注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 映射文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 映射文件进行映射。有鉴于此，如果存在一个同名 XML 映射文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。具体细节稍后讨论。</p><h3 id="从-SqlSessionFactory-中获取-SqlSession"><a href="#从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession"></a>从 SqlSessionFactory 中获取 SqlSession</h3><h4 id="通过SQLSession实例直接执行已映射的SQL语句"><a href="#通过SQLSession实例直接执行已映射的SQL语句" class="headerlink" title="通过SQLSession实例直接执行已映射的SQL语句"></a>通过SQLSession实例直接执行已映射的SQL语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁明了版</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="已映射的SQL语句"><a href="#已映射的SQL语句" class="headerlink" title="已映射的SQL语句"></a>已映射的SQL语句</h4><p>xml版：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// xml语句</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>java版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java较为简洁但建议用xml映射语句</p><h3 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h3><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p><h4 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h4><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h2><h3 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">    // 固定的username和password</span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态版：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p><ul><li>首先读取在 properties 元素体内指定的属性。</li><li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li><li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li></ul><h3 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 完整版</span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeResultHandlerEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultScriptingLanguage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.apache.ibatis.scripting.xmltags.XMLLanguageDriver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultEnumTypeHandler&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;callSettersOnNulls&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;returnInstanceForEmptyRow&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logPrefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exampleLogPreFix_&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;proxyFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;CGLIB | JAVASSIST&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;vfsImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.example.YourselfVfsImpl&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useActualParamName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;configurationFactory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.example.ConfigurationFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h3><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p><ul><li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li></ul><p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);</span><br><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);</span><br></pre></td></tr></table></figure><p>如果忽略了环境参数，那么将会加载默认环境，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);</span><br></pre></td></tr></table></figure><p>environments 元素定义了如何配置环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">  &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">    &lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt;</span><br><span class="line">    &lt;/transactionManager&gt;</span><br><span class="line">    &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">    &lt;/dataSource&gt;</span><br><span class="line">  &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure><p>注意一些关键点:</p><ul><li>默认使用的环境 ID（比如：default&#x3D;”development”）。</li><li>每个 environment 元素定义的环境 ID（比如：id&#x3D;”development”）。</li><li>事务管理器的配置（比如：type&#x3D;”JDBC”）。</li><li>数据源的配置（比如：type&#x3D;”POOLED”）。</li></ul><p>默认环境和环境 ID 顾名思义。 环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。</p><p><strong>事务管理器（transactionManager）</strong></p><p>在 MyBatis 中有两种类型的事务管理器（也就是 type&#x3D;”[JDBC|MANAGED]”）：</p><ul><li><p>JDBC – 这个配置直接使用了 JDBC 的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。默认情况下，为了与某些驱动程序兼容，它在关闭连接时启用自动提交。然而，对于某些驱动程序来说，启用自动提交不仅是不必要的，而且是一个代价高昂的操作。因此，从 3.5.10 版本开始，你可以通过将 “skipSetAutoCommitOnClose” 属性设置为 “true” 来跳过这个步骤。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transactionManager type=&quot;JDBC&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;skipSetAutoCommitOnClose&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/transactionManager&gt;</span><br></pre></td></tr></table></figure></li><li><p>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transactionManager type=&quot;MANAGED&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/transactionManager&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>白盒测试技术</title>
    <link href="https://www.bebella.cc/2022/10/06/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.bebella.cc/2022/10/06/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/</id>
    <published>2022-10-06T12:42:33.000Z</published>
    <updated>2023-07-01T13:49:51.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="（一）白盒测试技术概述"><a href="#（一）白盒测试技术概述" class="headerlink" title="（一）白盒测试技术概述"></a>（一）白盒测试技术概述</h2><h3 id="1-白盒测试基本原理"><a href="#1-白盒测试基本原理" class="headerlink" title="1. 白盒测试基本原理"></a>1. 白盒测试基本原理</h3><ul><li><p>白盒测试，侧重系统or部件内部机制的测试。</p><blockquote><p>分支测试（判定节点测试）、路径测试、语句测试</p></blockquote></li><li><p>又称结构测试、透明盒测试、逻辑驱动测试or基于代码的测试。</p><p>已知产品的内部工作过程，主要对程序内部结构展开测试，关注程序实现的细节</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vuwn5uuij207z03qglq.jpg" alt="image.png"></p><h3 id="2-白盒测试关注的对象"><a href="#2-白盒测试关注的对象" class="headerlink" title="2. 白盒测试关注的对象"></a>2. 白盒测试关注的对象</h3><ul><li>源代码</li><li>程序结构</li></ul><h3 id="3-白盒测试优缺点"><a href="#3-白盒测试优缺点" class="headerlink" title="3. 白盒测试优缺点"></a>3. 白盒测试优缺点</h3><p>优点：</p><ul><li>针对性强，便于快速定位，测试效率高</li><li>函数级别开始测试工作，缺陷修复成本低</li><li>通过不同的白盒覆盖指标有助于了解和衡量对被测对象的测试覆盖程度</li><li>有助于代码优化和缺陷预防</li></ul><p>缺点：</p><ul><li>对测试人员的技术要求高<ul><li>需要有一定的编程经验</li><li>白盒测试工程师需要具备广博的知识面</li></ul></li><li>成本高<ul><li>白盒测试的准备时间比较长</li></ul></li></ul><h3 id="4-白盒测试的问题"><a href="#4-白盒测试的问题" class="headerlink" title="4. 白盒测试的问题"></a>4. 白盒测试的问题</h3><ul><li>软件测试不是完备的</li><li>软件测试有风险</li><li>测试设计应该达到的目标<ul><li>提高效率</li><li>降低风险</li><li>在代码级别提高软件质量</li></ul></li></ul><h3 id="5-控制流分析技术"><a href="#5-控制流分析技术" class="headerlink" title="5. 控制流分析技术"></a>5. 控制流分析技术</h3><h4 id="1-什么是控制流分析？"><a href="#1-什么是控制流分析？" class="headerlink" title="1. 什么是控制流分析？"></a>1. 什么是控制流分析？</h4><p>就是根据程序的控制结构所反映的执行流流动规律建立起每一个程序执行点在控制结构中与其前驱或后继执行点在执行顺序上的对应关系，即流图。 流图直接反映了程序所有可能的执行路径以及执行流的运动规律</p><h4 id="2-控制流分析要解决的问题"><a href="#2-控制流分析要解决的问题" class="headerlink" title="2. 控制流分析要解决的问题"></a>2. 控制流分析要解决的问题</h4><ul><li>什么因素导致程序结构变的复杂</li><li>如何衡量程序结构的复杂程度</li><li>控制程序执行流程发生变化的主要因素是什么</li><li>如何测试这些因素并且确保测试的效率</li></ul><h4 id="3-控制流分析内容"><a href="#3-控制流分析内容" class="headerlink" title="3. 控制流分析内容"></a>3. 控制流分析内容</h4><ul><li>关注判定节点固有的复杂性<ul><li>焦点：判定表达式</li><li>方法：逻辑覆盖测试</li></ul></li><li>关注判定结构与循环结构对执行路径产生的影响<ul><li>焦点：路径</li><li>方法：基本（独立）路径测试</li></ul></li><li>关注循环结构本身复杂性<ul><li>焦点：循环体</li><li>方法：基于数据的静态分析</li></ul></li></ul><h3 id="6-常见的程序结构"><a href="#6-常见的程序结构" class="headerlink" title="6. 常见的程序结构"></a>6. 常见的程序结构</h3><h4 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1. 线性结构"></a>1. 线性结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv51fwedj20cc05st95.jpg" alt="线性结构"></p><h4 id="2-条件判定结构"><a href="#2-条件判定结构" class="headerlink" title="2. 条件判定结构"></a>2. 条件判定结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv5mnh4kj20fw066jse.jpg" alt="条件判定结构"></p><h4 id="3-While循环结构"><a href="#3-While循环结构" class="headerlink" title="3. While循环结构"></a>3. While循环结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv69vq17j20e505tmxv.jpg" alt="While循环结构"></p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv6z6f16j20cq05ht9f.jpg" alt="Do-While结构"></p><h3 id="7-白盒测试分类"><a href="#7-白盒测试分类" class="headerlink" title="7. 白盒测试分类"></a>7. 白盒测试分类</h3><p>可以分为两大类</p><h4 id="1-动态白盒测试"><a href="#1-动态白盒测试" class="headerlink" title="1. 动态白盒测试"></a>1. 动态白盒测试</h4><p>又称结构化测试。运行使用程序条件下找bug。</p><p>主要有逻辑覆盖测试、基本（独立）路径测试</p><h4 id="2-静态白盒测试"><a href="#2-静态白盒测试" class="headerlink" title="2. 静态白盒测试"></a>2. 静态白盒测试</h4><p>又称结构分析。不执行软件的条件下找出bug</p><p>主要有静态结构分析、静态质量度量、代码检查方法等等。</p><h3 id="8-逻辑覆盖猜测试（对判定）"><a href="#8-逻辑覆盖猜测试（对判定）" class="headerlink" title="8. 逻辑覆盖猜测试（对判定）"></a>8. 逻辑覆盖猜测试（对判定）</h3><p>原理：以程序内部的逻辑结构为基础的用例设计方法，通过对程序的逻辑结构的遍历，来实现测试对程序的覆盖。</p><p>关注点：判定表达式本身的复杂度</p><p>基本原则：对程序代码中所有的逻辑值，都需要测试其真值（True）和假值（False）的情况 </p><p>根据不同测试要求，逻辑覆盖测试可以分为：</p><ul><li>语句覆盖</li><li>判定覆盖（分支覆盖）</li><li>条件覆盖</li><li>判定-条件覆盖（分支-条件覆盖）</li><li>条件组合覆盖</li><li>路径覆盖</li></ul><h4 id="逻辑测试相关概念"><a href="#逻辑测试相关概念" class="headerlink" title="逻辑测试相关概念"></a>逻辑测试相关概念</h4><p>测试覆盖率 ：</p><ul><li>$覆盖率 &#x3D; 至少被执行一次的item总数 &#x2F; item总数$<ul><li>功能覆盖率：大致用于表示软件已经实现的功能和软件需要实现的功能之间的比例关系</li><li>结构覆盖率：包括语句覆盖率，分支覆盖率，路径覆盖率，循环覆盖率</li></ul></li><li>不一定要达到100%，也可以设置一个指标，达到这个指标后就认为达到了测试的效果</li></ul><h4 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h4><h5 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h5><p>设计测试用例时应保证程序中<strong>每一条可执行语句至少应该执行一次</strong>（点覆盖）</p><p>语句覆盖是最弱的一种覆盖标准</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w83fprpuj20h407u3z9.jpg" alt="语句覆盖"></p><h5 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h5><ul><li>关注语句，而非关注判定节点</li><li>对隐式分支无效</li></ul><h5 id="对策："><a href="#对策：" class="headerlink" title="对策："></a>对策：</h5><ul><li>优选测试数据</li><li>更强的覆盖准则：判定覆盖</li></ul><h4 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2. 判定覆盖"></a>2. 判定覆盖</h4><h5 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h5><p>又称分支覆盖。设计测试用例时，要保证程序中<strong>每个判定节点</strong>取得每种可能的结果至少一次。或者程序中每个判定的真分支和假分支至少执行一次。（边覆盖）</p><h5 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h5><ul><li>当判断节点中包含的是复合判定表达式时，即由多个简单判定条件（子条件）通过“与”、“或”关系连接而成的判定</li><li>此时，判定覆盖仅关心表达式的整体取值，并不关系局部组成，导致漏洞</li><li>故需要更严格的覆盖准则—-条件覆盖</li></ul><h4 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h4><h5 id="基本思想：-2"><a href="#基本思想：-2" class="headerlink" title="基本思想："></a>基本思想：</h5><p>设计测试用例时应保证程序中<strong>每个复合判定表达式</strong>中，每个简单的判定条件（子条件）的取真和取假情况至少执行一次。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w8s98hajj205v02jdg3.jpg" alt="条件覆盖"></p><p>实际上belike拆分成原子语句</p><p>局限性：</p><ul><li>并不能确保满足判定覆盖</li><li>相比判定覆盖，条件覆盖虽然进一步深入检查了判定节点中的每个子条件，但局部的完全覆盖不能保证对判定节点整体的完全覆盖</li><li>so需要更全面的覆盖准则—-判定-条件覆盖</li></ul><h4 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定-条件覆盖"></a>4. 判定-条件覆盖</h4><p>设计测试用例时，满足以下条件：</p><ul><li><p>判定节点的取真、取假分支至少执行一次</p></li><li><p>且每个简单的判定条件（子条件）的取真和取假情况也至少执行一次</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w9k3n7s8j20gr050q4w.jpg" alt="判定-条件覆盖"></p></li></ul><h4 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h4><p>每个判定节点中，所有简单判定条件（子条件）的所有可能的取值组合情况至少执行一次</p><p>本质：通过列真值表来得到完全覆盖</p><p>优势：</p><ul><li>覆盖前面all</li><li>方法简单，穷举法</li></ul><p>局限性：</p><ul><li>不能保证所有组合的路径被执行</li><li>测试用例太多</li><li>冗余严重</li></ul><h4 id="6-路径覆盖"><a href="#6-路径覆盖" class="headerlink" title="6. 路径覆盖"></a>6. 路径覆盖</h4><h5 id="基本要求："><a href="#基本要求：" class="headerlink" title="基本要求："></a>基本要求：</h5><p>要求设计足够的测试用例，运行被测程序，覆盖程序中all可能组合的路径</p><p>范围最广</p><h4 id="7-各方法之间关系"><a href="#7-各方法之间关系" class="headerlink" title="7. 各方法之间关系"></a>7. 各方法之间关系</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w9x227dsj20hj07o401.jpg" alt="对比图"></p><h2 id="（二）逻辑覆盖测试-x2F-对判定的测试"><a href="#（二）逻辑覆盖测试-x2F-对判定的测试" class="headerlink" title="（二）逻辑覆盖测试&#x2F;对判定的测试"></a>（二）逻辑覆盖测试&#x2F;对判定的测试</h2><h2 id="（三）基本路径测试-x2F-对路径的测试"><a href="#（三）基本路径测试-x2F-对路径的测试" class="headerlink" title="（三）基本路径测试&#x2F;对路径的测试"></a>（三）基本路径测试&#x2F;对路径的测试</h2><h3 id="1-相关术语概念"><a href="#1-相关术语概念" class="headerlink" title="1. 相关术语概念"></a>1. 相关术语概念</h3><p><strong>在程序控制流图中</strong>，通过对控制构造的环路复杂性分析而导出的基本的，可执行的独立路径集合。</p><p><strong>基本路径测试：</strong></p><p><strong>工作原理：</strong>借鉴线性代数的向量空间和向量基的概念，将程序中所有路径的集合看作一个向量空间，其中有限条的路径构成一组向量基，这组向量基对应的路径线性无关，或这组路径相互独立，即是独立路径，路径集合中其余非独立路径都可以用这组向量基来表示。测试这组向量基对应的独立路径就等同于对整个路径集合进行测试。之后根据独立路径设计测试用例。</p><h4 id="控制流图-x2F-程序图"><a href="#控制流图-x2F-程序图" class="headerlink" title="控制流图&#x2F;程序图"></a>控制流图&#x2F;程序图</h4><ul><li>控制流图：由节点和控制流线两种图形符号组成</li><li>用来表示程序结构的一种有向图</li><li>节点以标有编号的圆圈表示</li></ul><h4 id="环复杂度-x2F-圈复杂度"><a href="#环复杂度-x2F-圈复杂度" class="headerlink" title="环复杂度&#x2F;圈复杂度"></a>环复杂度&#x2F;圈复杂度</h4><p>环复杂度的计算：</p><ol><li><p>直观观察法</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cn0xg3mij20dy070jsd.jpg" alt="McCabe"></p></li><li><p>公式计算法</p><ul><li>注意前提</li></ul><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cn4ohzfnj20li099q5f.jpg" alt="计算法"></p></li><li><p>判定节点法</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cn5lxc5pj20gr08qta6.jpg" alt="判定节点法"></p></li></ol><h3 id="2-路径测试要解决的关键问题"><a href="#2-路径测试要解决的关键问题" class="headerlink" title="2. 路径测试要解决的关键问题"></a>2. 路径测试要解决的关键问题</h3><h4 id="1-如何获得独立路径所需要的路径地图？"><a href="#1-如何获得独立路径所需要的路径地图？" class="headerlink" title="1. 如何获得独立路径所需要的路径地图？"></a>1. 如何获得独立路径所需要的路径地图？</h4><h5 id="生成路径地图："><a href="#生成路径地图：" class="headerlink" title="生成路径地图："></a>生成路径地图：</h5><ul><li>程序流程图、控制流图&#x2F;程序图</li><li>共性：<ul><li>能准确反映程序结构</li><li>可以完整反映程序的所有执行路径</li><li>具有唯一性</li></ul></li><li>选择<strong>控制流图&#x2F;程序图</strong>作为路径地图</li></ul><h4 id="2-如何计算独立路径集合的规模？"><a href="#2-如何计算独立路径集合的规模？" class="headerlink" title="2. 如何计算独立路径集合的规模？"></a>2. 如何计算独立路径集合的规模？</h4><p>根据McCabe理论，<strong>独立路径集合的规模&#x3D;程序图的环复杂度</strong></p><h4 id="3-根据给定的路径集合，如何找到一组独立路径？确保路径的独立性和基本路径测试的完备性。"><a href="#3-根据给定的路径集合，如何找到一组独立路径？确保路径的独立性和基本路径测试的完备性。" class="headerlink" title="3. 根据给定的路径集合，如何找到一组独立路径？确保路径的独立性和基本路径测试的完备性。"></a>3. 根据给定的路径集合，如何找到一组独立路径？确保路径的独立性和基本路径测试的完备性。</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cv3vl1rvj20ne0aw0wl.jpg" alt="独立路径"></p><p>主路径：选取包含判定节点最多的路径作为主路径</p><h3 id="3-关于不可达路径"><a href="#3-关于不可达路径" class="headerlink" title="3.  关于不可达路径"></a>3.  关于不可达路径</h3><p>不可行路径不能用于设计测试用例</p><p>不可行路径对测试带来的影响：</p><ul><li>破坏了基本路径测试的完备性和无冗余性</li><li>增大了测试用例设计的难度</li></ul><p>如何处理不可行路径？</p><ul><li>结合源代码寻找独立路径，确保可实际执行</li><li>去掉不可行路径</li><li>为降低风险，补充其他具有较高风险的路径进行测试</li></ul><h3 id="4-测试分析"><a href="#4-测试分析" class="headerlink" title="4. 测试分析"></a>4. 测试分析</h3><ul><li>基本路径测试的理论基础保证了测试的完备行和无冗余性</li><li>使用基本路径测试能够保证语句覆盖</li><li>基本路径测试是用于多个判定节点串联和存在循环的情况</li><li>避免引入不可行了路径是程序优化的思想</li><li>基于程序图and环复杂度的基本路径测试仅关注<strong>结构的测试覆盖</strong></li></ul><h3 id="补充：循环测试"><a href="#补充：循环测试" class="headerlink" title="补充：循环测试"></a>补充：循环测试</h3><p>从本质上说，循环测试的目的：</p><ul><li>检查循环结构的有效性，循环过程的正确性</li></ul><p>通常循环可以分为四类：</p><ul><li>简单循环</li><li>嵌套循环</li><li>串接循环</li><li>非结构循环</li></ul><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cvzxgga4j20f207i76g.jpg" alt="循环分类"></p><h4 id="1-测试简单循环"><a href="#1-测试简单循环" class="headerlink" title="1. 测试简单循环"></a>1. 测试简单循环</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cw0majhkj20n608iwgx.jpg" alt="image.png"></p><h4 id="2-测试嵌套循环"><a href="#2-测试嵌套循环" class="headerlink" title="2. 测试嵌套循环"></a>2. 测试嵌套循环</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cw6ovsr1j20mh053mz8.jpg" alt="image.png"></p><h4 id="3-测试串接循环"><a href="#3-测试串接循环" class="headerlink" title="3. 测试串接循环"></a>3. 测试串接循环</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cw83bamuj20ll01pjrr.jpg" alt="image.png"></p><h4 id="4-对于非结构循环"><a href="#4-对于非结构循环" class="headerlink" title="4. 对于非结构循环"></a>4. 对于非结构循环</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cw88d0yrj20kq00pjrk.jpg" alt="image.png"></p><h3 id="补充2：Z路径覆盖测试"><a href="#补充2：Z路径覆盖测试" class="headerlink" title="补充2：Z路径覆盖测试"></a>补充2：Z路径覆盖测试</h3><p>路径覆盖的一种变体，将程序中的循环结构简化为选择结构</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7cwqwxt8kj20mj02zjsq.jpg" alt="image.png"></p><h2 id="（四）静态白盒技术"><a href="#（四）静态白盒技术" class="headerlink" title="（四）静态白盒技术"></a>（四）静态白盒技术</h2><h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h3><p>静态白盒测试，又称为结构分析，是在不执行程序的条件下审查软件设计、体系结构和代码，从而找出软件缺陷的过程。测试对象是文档、代码等非计算机执行的部分</p><h4 id="为什么要静态测试？"><a href="#为什么要静态测试？" class="headerlink" title="为什么要静态测试？"></a>为什么要静态测试？</h4><p>为了降低缺陷修复的成本及发现缺陷的成本，应该在开发活动的早期进行静态测试，尽早在动态测试之前去发现缺陷并修改缺陷。</p><p><strong>软件测试是控制成本的关键</strong></p><h3 id="1-代码检查"><a href="#1-代码检查" class="headerlink" title="1. 代码检查"></a>1. 代码检查</h3><p>主要检查代码和程序设计的一致性，代码结构的合理性，代码编写的标准性、可读性，代码逻辑表达的正确性等方面。</p><p>主要参考文档为：</p><ul><li>程序设计文档</li><li>程序的源代码清单</li><li>编码规范</li><li>代码缺陷检查表等。</li></ul><p>代码检查能快速找到缺陷，一旦发现错误，能够在代码中对其进行精确定位，从而降低了错误修正的成本。代码检查看到的是问题本身而非问题的征兆。代码检查非常耗费时间，而且代码检查需要知识和经验的积累。</p><p>代码检查包括三种方式：</p><ul><li>代码审查</li><li>代码走查</li><li>桌面检查</li></ul><blockquote><p><strong>代码审查和走查</strong>都是以小组为单位阅读代码，它是一系列规程和错误检查方法的集合。</p><p><strong>代码审查</strong>主要是通过同行评审来发现缺陷。</p><p>同行评审，主要是以评审会议为形式，通过多人（软件工作产品生产者的同行）遵循已定义的规程对软件交付物（源代码、设计规格书等）进行技术评审。其核心是预防缺陷。其目的是发现和修复软件开发初期未发现的缺陷，获得改进优化的机会。同行评审往往需要大量投入时间和人力资源。</p></blockquote><h4 id="（1）代码审查—-同行评审"><a href="#（1）代码审查—-同行评审" class="headerlink" title="（1）代码审查—-同行评审"></a>（1）代码审查—-同行评审</h4><p>同行评审≠测试</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7kca8qvkaj20fe095mzr.jpg" alt="image.png"></p><p>评审流程：</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h7kcb0ed7pj20jp07egoq.jpg" alt="image.png"></p><p>评审的五个角色：</p><ul><li>记录员</li><li>讲解员</li><li>主持人</li><li>程序编写者</li><li>评审员</li></ul><h4 id="2-简述同行评审流程"><a href="#2-简述同行评审流程" class="headerlink" title="2. 简述同行评审流程"></a>2. 简述同行评审流程</h4><p>（1）计划评审会议</p><ul><li>设计部门：评审前3天，向项目管理部门提交《设计和开发评审申请表》，经批准后进入计划评审会议阶段；</li><li>项目经理：根据申请表指定合适的会议主持人（协调员）；</li><li>作者（程序员）：提供工作产品用于评审，并确保工作产品符合相关标准和规范；</li><li>主持人（协调员）：规划本次评审会议，具体工作包括制定评审计划等。</li></ul><p>（2）召开评审预备会</p><p>评审人员向主持人提出申请，由主持人决定是否需要召开评审预备会。时间＜ 2h。<br>目的是确保参加正式评审会议的人员能清楚地了解评审流程和评审目的，正确理解自己的责任，且评审员得到的评审材料正确无误。</p><p>（3）准备评审会议</p><p>评审员：检查工作产品，记录发现的缺陷，填写审阅情况记录表，反馈给主持人</p><p>主持人：汇总收集的审阅情况记录表，并判断是否需要增加评审的投入</p><p>（4）召开正式评审会议</p><ul><li>主持人：召开会议。包括主持会议，控制会议进度,维持会议程<br>序，决定是否要召开第3小时会议，会后提交评审报告，给出评审<br>结论；</li><li>讲解员：讲解工作产品。引导评审员浏览工作产品；<br>共同确认问题；</li><li>评审员：听取讲解,发表意见，指出问题,与作者确定问题、定<br>义问题的严重程度：</li><li>作者倾听讲解和评审员的意见，回答提问；</li><li>记录员：记录每个达成共识的缺陷,确保评审员同意对问题的记<br>录，并记录未达成共识的缺陷.标记为TBD （待确定），作为第3<br>小时会议评审的对象更新审阅情况记录表</li></ul><p>（5）召开第3小时会议</p><ul><li>主持人：主持会议，维持会议程序，控制会议进度，并在会议结束后负责更新审阅情况记录表,撰写评审报告,给出评审结论。</li><li>评审员：对标记为TBD的问题进行讨论，给出确定的意见，并针对已经达成共识的缺陷的修复方案提出自己的意见。</li><li>作者：倾听评审员的意见，提出自己的看法。</li><li>记录员：记录每个达成共识的缺陷及其对应的解决方案。</li></ul><p>（6）修复缺陷</p><p>作者（程序员）：修改工作产品。针对提交的审阅情况记录表，对每个缺陷进行定位、调试和修复，然后提交修复后的工作产品，同时更新审阅情况记录表，在表格中简要说明对每个缺陷的修复过程。对缺陷清单进行分析和整理，以便于对缺陷检查表进行扩充，在后续的静态测试中，提供给评审员，从而提高后续静态测试的效率。</p><p>（7）确认修复</p><ul><li>主持人：指派专人对修复后的工作产品进行确认。查看最终提交的审阅情况记录表，判断工作产品是否符合退出标准。</li><li>评审员：对照更新后的审阅情况记录表，检查修复后的工作产品，判断是否所有缺陷均得到正确的修复，且未弓I入新的缺陷。否则打回给作者要求其继续修复。若所有缺陷都已确认修复，则更新审阅情况记录表，并提交给主持人。</li></ul><h2 id="（五）白盒测试工具Junit的使用"><a href="#（五）白盒测试工具Junit的使用" class="headerlink" title="（五）白盒测试工具Junit的使用"></a>（五）白盒测试工具Junit的使用</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;（一）白盒测试技术概述&quot;&gt;&lt;a href=&quot;#（一）白盒测试技术概述&quot; class=&quot;headerlink&quot; title=&quot;（一）白盒测试技术概述&quot;&gt;&lt;/a&gt;（一）白盒测试技术概述&lt;/h2&gt;&lt;h3 id=&quot;1-白盒测试基本原理&quot;&gt;&lt;a href=&quot;#1-白盒测试基</summary>
      
    
    
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="https://www.bebella.cc/2022/10/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.bebella.cc/2022/10/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-10-06T10:57:01.000Z</published>
    <updated>2023-07-01T13:52:23.969Z</updated>
    
    <content type="html"><![CDATA[<h4 id="6-什么是软件缺陷（BUG）"><a href="#6-什么是软件缺陷（BUG）" class="headerlink" title="6. 什么是软件缺陷（BUG）"></a>6. 什么是软件缺陷（BUG）</h4><p>第一个bug：</p><ul><li>Grace Hopper 计算机软件之母</li><li>1945.9.9</li><li>First actual case of bug being found</li></ul><p>著名软件故障：</p><ul><li>”算不准”的cpu【功能问题】</li><li>“哭泣”的狮子王【兼容性问题】</li><li>“失控”的动车【容错性问题】</li><li>“消失”的火星探测器【集成性问题】</li><li>“拒绝访问”的Gmail【性能问题】</li></ul><p>软件测试的必要性：</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vrviftnmj20jv05f0ud.jpg" alt="image.png"></p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vrvw4aewj20k002dwf8.jpg" alt="image.png"></p><p>软件缺陷的正式定义：（符合一个就算）</p><ol><li>软件测试员认为难以理解，不易使用，运行速度缓慢or最终用户认为软件是用效果不好的</li><li>软件未达到需求规格说明书中指明的功能</li><li>软件出现了需求规格说明书中不会出现的错误</li><li>软件功能超出需求规格说明书中指明的范围</li><li>软件未达到需求规格说明书总虽未指出但应该达到的指标</li></ol><h4 id="7-什么是测试用例"><a href="#7-什么是测试用例" class="headerlink" title="7. 什么是测试用例"></a>7. 什么是测试用例</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vs2h9qazj20e502l3z2.jpg" alt="image.png"></p><p>测试用例的基本属性</p><ul><li>典型性（代表性）</li><li>可测试性（可判定性）</li><li>可重现性</li><li>独立性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;6-什么是软件缺陷（BUG）&quot;&gt;&lt;a href=&quot;#6-什么是软件缺陷（BUG）&quot; class=&quot;headerlink&quot; title=&quot;6. 什么是软件缺陷（BUG）&quot;&gt;&lt;/a&gt;6. 什么是软件缺陷（BUG）&lt;/h4&gt;&lt;p&gt;第一个bug：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="课程作业" scheme="https://www.bebella.cc/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
