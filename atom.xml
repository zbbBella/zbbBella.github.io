<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bella</title>
  
  <subtitle>收集人生成就中</subtitle>
  <link href="https://www.bebella.cc/atom.xml" rel="self"/>
  
  <link href="https://www.bebella.cc/"/>
  <updated>2022-09-27T02:07:40.618Z</updated>
  <id>https://www.bebella.cc/</id>
  
  <author>
    <name>Bella</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库访问技术</title>
    <link href="https://www.bebella.cc/2022/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.bebella.cc/2022/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF/</id>
    <published>2022-09-26T10:41:34.000Z</published>
    <updated>2022-09-27T02:07:40.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统数据库访问"><a href="#传统数据库访问" class="headerlink" title="传统数据库访问"></a>传统数据库访问</h2><p>编程语言访问数据库的步骤：</p><p>API（ .jar）—- 连接类：连接字符串，连接数据库 —- 命令类：SQL语句 —- 执行SQL —- 接收SQL执行的结果</p><p>注意点：</p><ul><li>参数化SQL命令（防止SQL注入攻击问题）<ul><li>SQL命令由多个字符串拼接而成</li></ul></li><li>抽取一个数据库访问辅助类</li><li>把连接字符串写进配置文件</li></ul><p>数据访问层DAO&#x2F;DAL</p><p>****Dao接口 —- ***DAOImpl</p><p>UserDao —- UserDaoImpl </p><p>UserDao —- UserDaoImp1 —- 专门访问数据库里的user表，CRUD</p><p>CourseDao —-</p><p>业务逻辑层（BLL&#x2F;Service）</p><p>UserService —- UserServiceImpl —- 专门处理User表</p><p>界面层（UI —- 前后端分离）</p><p>maven</p><p>问题：</p><p>一个项目里可能用到很多个 .jar</p><p>（1）手动管理麻烦</p><p>（2）重复很严重</p><p>（3）版本冲突</p><h2 id="JDBC访问数据库"><a href="#JDBC访问数据库" class="headerlink" title="JDBC访问数据库"></a>JDBC访问数据库</h2><h3 id="1-加载JDBC驱动程序"><a href="#1-加载JDBC驱动程序" class="headerlink" title="1.  加载JDBC驱动程序"></a>1.  加载JDBC驱动程序</h3><p>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM，这通过反射实现。成功加载后，会将Driver类的实例注册到DriverManager类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 加载数据库驱动，此语句加载的是8.0版本的mysql</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2.  连接数据库"></a>2.  连接数据库</h3><p>书写形式：协议：子协议：数据源标识 。 其中：</p><p>协议：在JDBC中总是以jdbc开始 。子协议：是桥连接的驱动程序或是数据库管理系统名称。  数据源标识：标记找到数据库来源的地址与连接端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connetcion</span> <span class="variable">connect</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// &quot;jdbc:mysql://DatabaseName?servertimezone&quot;,&quot;username&quot;,&quot;password&quot;</span></span><br><span class="line">connect = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///myschool?serverTimezone=Hongkong&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-创建一个Statement"><a href="#3-创建一个Statement" class="headerlink" title="3. 创建一个Statement"></a>3. 创建一个Statement</h3><p> 要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：</p><ul><li>执行静态SQL语句。通常通过Statement实例实现。</li><li>执行动态SQL语句。通常通过PreparedStatement实例实现。</li><li>执行数据库存储过程。通常通过CallableStatement实例实现。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statment statment = null;</span><br><span class="line">statment = connect.createStatement();</span><br></pre></td></tr></table></figure><h3 id="4-执行SQL语句"><a href="#4-执行SQL语句" class="headerlink" title="4. 执行SQL语句"></a>4. 执行SQL语句</h3><p>Statement 接口提供三种执行SQL语句的方法：</p><ul><li>executeQuery</li><li>executeUpdate</li><li>execute</li></ul><blockquote><p>   ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句，返回一个结果集（ResultSet）对象。<br>   int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等<br>   execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的语句。</p></blockquote><h3 id="5-处理结果-ResultSet"><a href="#5-处理结果-ResultSet" class="headerlink" title="5.  处理结果 ResultSet"></a>5.  处理结果 ResultSet</h3><p>两种情况：  </p><ul><li>执行更新返回的是本次操作影响到的记录数。  </li><li>执行查询返回的结果是一个ResultSet对象。</li></ul><p> ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs=statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读出数据</span></span><br><span class="line"><span class="keyword">while</span> (rest.next()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rest.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> rest.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(id + <span class="string">&quot; &quot;</span> + username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-关闭JDBC对象"><a href="#6-关闭JDBC对象" class="headerlink" title="6.  关闭JDBC对象"></a>6.  关闭JDBC对象</h3><p>  操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：</p><ul><li>关闭记录集</li><li>关闭声明  </li><li>关闭连接对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeRs</span><span class="params">(ResultSet rs)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(rs != <span class="literal">null</span> )&#123;</span><br><span class="line"> rs.close();</span><br><span class="line"> rs = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//关闭执行方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeStmt</span><span class="params">(Statement stmt)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stmt != <span class="literal">null</span> )&#123;</span><br><span class="line"> stmt.close();</span><br><span class="line"> stmt = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="literal">null</span> )&#123;</span><br><span class="line"> conn.close();</span><br><span class="line"> conn = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传统数据库访问&quot;&gt;&lt;a href=&quot;#传统数据库访问&quot; class=&quot;headerlink&quot; title=&quot;传统数据库访问&quot;&gt;&lt;/a&gt;传统数据库访问&lt;/h2&gt;&lt;p&gt;编程语言访问数据库的步骤：&lt;/p&gt;
&lt;p&gt;API（ .jar）—- 连接类：连接字符串，连接数据库 </summary>
      
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象设计原则与设计模式</title>
    <link href="https://www.bebella.cc/2022/09/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.bebella.cc/2022/09/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-26T09:59:09.000Z</published>
    <updated>2022-09-26T10:41:16.581Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象设计原则：面向**<u>接口</u>**编程</p><p>程序错误：看报错信息</p><p>配置文件的作用：什么都可以写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象设计原则：面向**&lt;u&gt;接口&lt;/u&gt;**编程&lt;/p&gt;
&lt;p&gt;程序错误：看报错信息&lt;/p&gt;
&lt;p&gt;配置文件的作用：什么都可以写&lt;/p&gt;
</summary>
      
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Kaggle入门</title>
    <link href="https://www.bebella.cc/2022/09/23/Kaggle%E5%85%A5%E9%97%A8/"/>
    <id>https://www.bebella.cc/2022/09/23/Kaggle%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-23T05:47:59.000Z</published>
    <updated>2022-09-23T16:59:54.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Recap-of-main-ML-algorithms"><a href="#1-Recap-of-main-ML-algorithms" class="headerlink" title="1. Recap of main ML algorithms"></a>1. Recap of main ML algorithms</h2><h3 id="1-Linear"><a href="#1-Linear" class="headerlink" title="1 Linear"></a>1 Linear</h3><p>advantage:</p><p>适合稀疏的数据</p><p>disadvantage:</p><p>很多数据不能被简单的一条线分成两类</p><h3 id="2-Tree-based"><a href="#2-Tree-based" class="headerlink" title="2 Tree-based"></a>2 Tree-based</h3><p>决策树、随机森林、GBDT</p><p>需要大量分裂，很难找到线性相关性</p><h3 id="3-kNN（k最近邻）"><a href="#3-kNN（k最近邻）" class="headerlink" title="3  kNN（k最近邻）"></a>3  kNN（k最近邻）</h3><h3 id="4-Neural-Networks"><a href="#4-Neural-Networks" class="headerlink" title="4  Neural Networks"></a>4  Neural Networks</h3><h2 id="2-Feature-Preprocessing-and-Generation"><a href="#2-Feature-Preprocessing-and-Generation" class="headerlink" title="2. Feature Preprocessing and Generation"></a>2. Feature Preprocessing and Generation</h2><h3 id="1-Numeric-Features"><a href="#1-Numeric-Features" class="headerlink" title="1 Numeric Features"></a>1 Numeric Features</h3><p>Tree-based 不需要scaling</p><p>但是Non-tree-based就非常依赖scaling</p><h4 id="preprocessing"><a href="#preprocessing" class="headerlink" title="preprocessing"></a>preprocessing</h4><p>a. 0-1 正则化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.MinMaxScaler</span><br></pre></td></tr></table></figure><p>$X &#x3D; (X - X.min()) &#x2F; (X.max() - X.min()) $</p><p>b. 标准正则化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.StandardScaler</span><br></pre></td></tr></table></figure><p>$X &#x3D; (X - X.mean()) &#x2F; X.std() $</p><p>c. 异常值处理</p><ul><li>设定取值范围</li></ul><p>d. rank</p><ul><li>映射</li><li><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6h0k7hdnkj20c203ct91.jpg" alt="rank"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.stats.rankdata</span><br></pre></td></tr></table></figure><p>非树型 或 神经网络可以用：</p><ul><li><p>Log </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.log(1 + x)</span><br></pre></td></tr></table></figure></li><li><p>Raising to the power &lt; 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(x + 2/3)</span><br></pre></td></tr></table></figure></li></ul><h4 id="feature-generation"><a href="#feature-generation" class="headerlink" title="feature generation"></a>feature generation</h4><p>powered by:</p><ul><li>prior knowledge</li><li>EDA</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Recap-of-main-ML-algorithms&quot;&gt;&lt;a href=&quot;#1-Recap-of-main-ML-algorithms&quot; class=&quot;headerlink&quot; title=&quot;1. Recap of main ML algorithms&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="DataScience" scheme="https://www.bebella.cc/categories/DataScience/"/>
    
    
    <category term="Kaggle" scheme="https://www.bebella.cc/tags/Kaggle/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化与主从复制</title>
    <link href="https://www.bebella.cc/2022/09/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.bebella.cc/2022/09/23/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2022-09-22T17:40:40.000Z</published>
    <updated>2022-09-27T08:15:05.077Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1. 什么是持久化"></a>1. 什么是持久化</h3><p>​持久化可以理解为数据的永久存储，就是将数据存储到一个不会丢失的地方。如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化 的，而放在磁盘就是一种持久化。 </p><h3 id="2-Redis的持久化"><a href="#2-Redis的持久化" class="headerlink" title="2. Redis的持久化"></a>2. Redis的持久化</h3><ul><li><p>Redis 是内存型数据库，一般来用作缓存。</p></li><li><p>Redis的数据存储在内存中，系统宕机or重启，或Redis崩溃、重启，所有数据丢失</p></li><li><p>为解决此问题，提供两种机制对数据进行持久化储存，方便故障发生后迅速恢复数据。</p><blockquote><p>​保存在内存的数据有一个特点， 就是断电消失，因此一旦 Redis 宕机了，重启以后保存在 Redis 里面的数据就会消失， 此时服务器在 Redis 里面获取不到缓存，就会让缓存无法命中，导致缓存雪崩，请求直接打到 MySQL 上最后让 MySQL 也宕机。 因此我们需要 Redis 持久化来做灾难恢复、数据恢复还有数据库高可用。</p></blockquote></li></ul><h4 id="1-RDB文件"><a href="#1-RDB文件" class="headerlink" title="1. RDB文件"></a>1. RDB文件</h4><p>​redis database backup file，备份文件，默认持久化方式。</p><blockquote><p>就是在指定的时间间隔内将内存中的数据集快照写入磁盘。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为 RDB 文件，保存了在某个时间点的全部数据，默认是保存在当前运行目录，默认文件名是 <strong>dump.rdb</strong>，该文件会自动创建。</p><p>保存数据是在单独的进程中写文件。</p></blockquote><p>RDB触发条件：</p><ol><li><p>save</p><blockquote><p>save 命令会用主进程执行RDB，其他进程可能会被阻塞。</p></blockquote></li><li><p>bgsave （后台保存）</p><blockquote><p>可以异步执行 RDB：执行后会开启独立进程完成 RDB，主进程可以继续处理用户请求，不受影响</p></blockquote></li><li><p>Redis停机or宕机</p></li><li><p>触发RDB条件</p><blockquote><p>配置文件中有以下参数。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghd898iuj205c02p0sv.jpg" alt="image-20220923021247332.png"></p><p>save <seconds> <changes> ：当在<strong>N 秒内数据集至少有 M 个 key</strong> 改动这一条件被满足时， 自动保存一 次数据集</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghekfaegj208z01bjri.jpg" alt="image-20220923021413130.png"></p><p>配置文件名。默认为dump.rdb</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6gheuwxgwj20cl02d3yw.jpg" alt="image-20220923021434324.png"></p><p>配置存储路径，默认为当前目录。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghf5o0jdj20b501iaaf.jpg" alt="image-20220923021457606.png"></p><p>是否压缩RDB文件，建议no。</p></blockquote></li></ol><h4 id="2-AOF日志"><a href="#2-AOF日志" class="headerlink" title="2. AOF日志"></a>2. AOF日志</h4><p>​Append-only File，Redis 每次接收到一条<strong>更新数据</strong>的命令时，它将把该命令写到一个 AOF 文件中（只记录写操作，读操作不记录）。当 Redis 重启时，它通过执行 AOF 文件中所有的命令来恢复数据。 </p><p>三种像aof文件写命令数据的策略：</p><ol><li>no</li><li>always</li><li>everysec</li></ol><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghgp0mthj20gp02zdgs.jpg" alt="image-20220923021916762.png"></p><h3 id="3-RDB与AOF优缺点比较"><a href="#3-RDB与AOF优缺点比较" class="headerlink" title="3. RDB与AOF优缺点比较"></a>3. RDB与AOF优缺点比较</h3><p>RDB：</p><ul><li>体积小，适合备份传输</li><li>性能比AOF好，（AOF需要写入日志到文件中）。RDB恢复更快。</li></ul><p>但是：</p><ul><li>服务器故障时会丢失最后一次备份之后的数据。</li><li>Redis 保存rdb时， fork子进程的这个操作期间, Redis服务会停止响应(一般是毫秒级)，但如果数据量大且cpu时间紧张，则停止响应的时间可能长达1秒</li></ul><p>AOF：</p><ul><li>充分保证数据的持久化，正确的配置一般最多丢失1秒的数据</li><li>aof 文件内容是以Redis协议格式保存， 易读</li></ul><p>但是：</p><ul><li>文件RDB文件大，速度较慢</li><li>重新启动redis时会极低的概率会导致无法将数据集恢复成保存时的原样(概率极低, 但确实出现过)</li></ul><h3 id="4-相关配置（cmd版）"><a href="#4-相关配置（cmd版）" class="headerlink" title="4. 相关配置（cmd版）"></a>4. 相关配置（cmd版）</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ RDB  ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#rdb文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录。默认为当前目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">#aof文件名, 保存目录由 dir 参数决定</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#aof持久化策略的配置</span><br><span class="line">#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line"># 手动重写方式：命令 bgrewriteaop</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure><h3 id="5-Docker下持久化"><a href="#5-Docker下持久化" class="headerlink" title="5.  Docker下持久化"></a>5.  Docker下持久化</h3><h5 id="docker数据卷"><a href="#docker数据卷" class="headerlink" title="docker数据卷"></a>docker数据卷</h5><p>Docker 容器删除后，在容器中产生的数据就不在了，Docker 容器和外部机器不可以直接交换文件，容器之间想要进行数据交互就要通过数据卷</p><blockquote><p><strong>数据卷是什么：</strong></p><ul><li><p>数据卷是宿主机中的一个目录或文件</p></li><li><p>当容器目录和数据卷目录绑定后，对方的修改会立即同步</p></li><li><p>一个数据卷可以被多个容器同时挂载</p></li><li><p>一个容器也可以被挂载多个数据卷</p></li></ul><p><strong>数据卷的作用：</strong></p><ul><li><p>容器数据持久化</p></li><li><p>外部机器和容器间接通信</p></li><li><p>容器之间数据交换</p></li></ul></blockquote><h5 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h5><ol><li>创建redis容器并挂载数据卷<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name redis_1 -p 6379:6379 -v /e/redis/data:/data redis</span></span><br></pre></td></tr></table></figure>数据卷的实现: 创建启动容器时，使用–v 参数来设置数据卷</li></ol><p>语法：docker run -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名…..</p><ol start="2"><li>使用 redis-cli.exe 连接 redis 容器，写入数据，执行 RDB 操作</li><li>查看实现宿主机的目录和容器内目录的映射 </li><li>恢复数据：停止然后再次启动Redis容器</li></ol><h5 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h5><ol><li>创建redis容器并挂载数据卷</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name redis_2 -p 6379:6379 -v /d/redis/data:/data redis --appendonly <span class="built_in">yes</span></span></span><br><span class="line">// 该命令表示 redis_2 容器开启 AOF 持久化模式。但是，该参数只在当前命令 中有效</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用 redis-cli.exe 连接 redis 容器，写入数据，执行 RDB 操作</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l8cxe0sij20bq05m758.jpg" alt="image.png"></p></li><li><p>查看实现宿主机的目录和容器内目录的映射 </p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l8dcvx1sj206803cjrh.jpg" alt="image.png"></p></li><li><p>恢复数据：停止然后再次启动Redis容器</p></li></ol><h5 id="使用配置文件修改容器内Redis参数"><a href="#使用配置文件修改容器内Redis参数" class="headerlink" title="使用配置文件修改容器内Redis参数"></a>使用配置文件修改容器内Redis参数</h5><ol><li>创建”E:\redis\conf”文件夹，用于存放 redis.conf 文件；</li><li>创建redis.conf文件</li><li>修改所需参数</li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Q-什么是主从复制？"><a href="#Q-什么是主从复制？" class="headerlink" title="Q: 什么是主从复制？"></a>Q: 什么是主从复制？</h4><blockquote><p>主从复制，是将多台数据库服务器分为主节点（master）和从节点（slaver），主节点数据更新后会根据配置和策略，自动同步到从节点上，从而保证主从节点中存有相同的数据。</p><p>常见结构：</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l7jqt3r8j208g06t74s.jpg" alt="主从复制结构"></p></blockquote><h4 id="Q-主从复制作用？"><a href="#Q-主从复制作用？" class="headerlink" title="Q: 主从复制作用？"></a>Q: 主从复制作用？</h4><blockquote><ul><li>提升数据库系统的请求处理能力。</li><li>单个节点能够支撑的读流量有限。部署多个节点，并构成主从关系，主从节点一起提供服务</li><li>默认实现读写分离机制，Master 以写为主，Slave 以读为主，提升系统的缓存读写性能。</li><li>容灾快速恢复，提升整个系统的可用性。</li><li>因为从节点中有主节点数据的副本，当主节点宕机后，可以立刻提升其中一个从节点为主节点，继续提供服务</li></ul></blockquote><h4 id="Q-主从复制原理？"><a href="#Q-主从复制原理？" class="headerlink" title="Q: 主从复制原理？"></a>Q: 主从复制原理？</h4><p>直观的做法是主节点产生一份数据的快照发送给从节点，以快照数据为基准，将之后增量的数据变更同步给从节点，保证主从数据的一致。总体来看，主从复制一般包含全量数据同步、增量同步两个阶段。 </p><blockquote><ul><li>全量数据同步 </li><li>主节点产生一份全量数据的快照（RDB 文件），并将此快照发送给从节点。且从产生快照时刻起，记录新接收到的写命令。当快照发送完成后，将累积的写命令发送绐从节点，从节点执行这些写命令。一般用于主从节点首次数据同步，完成基准数据。</li><li>增量同步（命令传播） </li><li>全量数据同步完成后，主节点将执行过的写命令源源不断地发送给从节点，从节点执行这些命令，保证主从节点中数据有相同的变更，保证主从节点数据的一致。</li></ul></blockquote><h3 id="redis下主从复制"><a href="#redis下主从复制" class="headerlink" title="redis下主从复制"></a>redis下主从复制</h3><p>参考课件</p><h3 id="docker下的redis主从复制"><a href="#docker下的redis主从复制" class="headerlink" title="docker下的redis主从复制"></a>docker下的redis主从复制</h3><p>以一主二从为例。</p><ol><li><p>给三台Redis分配端口号</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-master -p 6379:6379 -d redis redis-server</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-slaver1 -p 6380:6379 -d redis redis-server</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-slaver2 -p 6381:6379 -d redis redis-server</span></span><br></pre></td></tr></table></figure></li><li><p>创建三个redis配置文件</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l7wdds09j20cl03rjsu.jpg" alt="三个配置文件"></p></li><li><p>查询三个redis在容器内ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 容器id可在docker desktop内复制</span><br><span class="line">docker inspect containerid(容器id)</span><br></pre></td></tr></table></figure></li><li><p>修改两个slave节点的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// slaveof &lt;master ipaddress&gt; &lt;master port&gt;</span><br><span class="line">slaveof 172.17.0.2 6379</span><br></pre></td></tr></table></figure></li><li><p>启动三台服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> (1)启动master:</span><br><span class="line"> docker run -id --name redis_master -p 6379:6379 --privileged=true -v /d/redis/data:/data -v /d/redis/conf/redis_6379.conf:/etc/redis/redis_6379.conf redis redis-server /etc/redis/redis_6379.conf</span><br><span class="line">   </span><br><span class="line">  (2)启动slave1:</span><br><span class="line"> docker run -id --name redis_slave1 -p 6380:6379 --privileged=true -v /d/redis/conf/redis_6380.conf:/etc/redis/redis_6380.conf redis redis-server /etc/redis/redis_6380.conf</span><br><span class="line"></span><br><span class="line">  (3)启动slave2:</span><br><span class="line">docker run -id --name redis_slave2 -p 6381:6379 --privileged=true -v /d/redis/conf/redis_6381.conf:/etc/redis/redis_6381.conf redis redis-server /etc/redis/redis_6381.conf</span><br></pre></td></tr></table></figure></li><li><p>查询主从身份</p><p>进入redis，输入<code>info replication</code></p></li><li><p>测试数据是否同步</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l84i2dtoj20fe04s74e.jpg" alt="结果"></p></li></ol><hr><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/182972002">https://zhuanlan.zhihu.com/p/182972002</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h2&gt;&lt;h3 id=&quot;1-什么是持久化&quot;&gt;&lt;a href=&quot;#1-什么是持久化&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="NoSQL" scheme="https://www.bebella.cc/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://www.bebella.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>反射机制与配置文件</title>
    <link href="https://www.bebella.cc/2022/09/22/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://www.bebella.cc/2022/09/22/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2022-09-22T05:49:48.000Z</published>
    <updated>2022-09-26T10:49:27.372Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="1. 什么是反射"></a>1. 什么是反射</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性（包括私有的方法和属性）；</li><li>这种<strong>动态获取的信息</strong>以及<strong>动态调用对象的方法</strong>的功能称为java语言的反射机制。</li></ul><p>反射就是把java类中的各种成分映射成一个个的Java对象。</p><blockquote><p><strong>反射是框架设计的灵魂</strong><br><strong>使用前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件 ( 字节码 )，而反射使用的就是Class类中的方法</strong></p><p><strong>注意：在运行期间，一个类，只有一个Class对象产生。</strong></p></blockquote><h2 id="2-反射用途"><a href="#2-反射用途" class="headerlink" title="2. 反射用途"></a>2. 反射用途</h2><p>​在日常的第三方应用开发反射来获取所需的私有成员或是方法。经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用 Java 的反射机制通过反射来获取所需的私有成员或是方法。</p><p>​当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值，这样就起到保护用户隐私的目的。</p><h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-什么是反射&quot;&gt;&lt;a href=&quot;#1-什么是反射&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是反射&quot;&gt;&lt;/a&gt;1. 什么是反射&lt;/h2&gt;&lt;h3 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello</title>
    <link href="https://www.bebella.cc/2022/09/22/Hello/"/>
    <id>https://www.bebella.cc/2022/09/22/Hello/</id>
    <published>2022-09-22T05:36:08.000Z</published>
    <updated>2022-09-22T05:38:12.889Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, I am Bella z. It would be my first blog and I would try to share my study notes, daily life, what I like etc.</p><p>Welcome!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello, I am Bella z. It would be my first blog and I would try to share my study notes, daily life, what I like etc.&lt;/p&gt;
&lt;p&gt;Welcome!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.bebella.cc/2022/09/20/hello-world/"/>
    <id>https://www.bebella.cc/2022/09/20/hello-world/</id>
    <published>2022-09-20T14:32:34.318Z</published>
    <updated>2022-09-20T14:32:34.318Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
