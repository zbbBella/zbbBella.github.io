<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bella</title>
  
  <subtitle>收集人生成就中</subtitle>
  <link href="https://www.bebella.cc/atom.xml" rel="self"/>
  
  <link href="https://www.bebella.cc/"/>
  <updated>2022-10-06T21:28:15.544Z</updated>
  <id>https://www.bebella.cc/</id>
  
  <author>
    <name>Bella</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>白盒测试技术</title>
    <link href="https://www.bebella.cc/2022/10/06/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.bebella.cc/2022/10/06/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF/</id>
    <published>2022-10-06T12:42:33.000Z</published>
    <updated>2022-10-06T21:28:15.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="（一）白盒测试技术概述"><a href="#（一）白盒测试技术概述" class="headerlink" title="（一）白盒测试技术概述"></a>（一）白盒测试技术概述</h2><h3 id="1-白盒测试基本原理"><a href="#1-白盒测试基本原理" class="headerlink" title="1. 白盒测试基本原理"></a>1. 白盒测试基本原理</h3><ul><li><p>白盒测试，侧重系统or部件内部机制的测试。</p><blockquote><p>分支测试（判定节点测试）、路径测试、语句测试</p></blockquote></li><li><p>又称结构测试、透明盒测试、逻辑驱动测试or基于代码的测试。</p><p>已知产品的内部工作过程，主要对程序内部结构展开测试，关注程序实现的细节</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vuwn5uuij207z03qglq.jpg" alt="image.png"></p><h3 id="2-白盒测试关注的对象"><a href="#2-白盒测试关注的对象" class="headerlink" title="2. 白盒测试关注的对象"></a>2. 白盒测试关注的对象</h3><ul><li>源代码</li><li>程序结构</li></ul><h3 id="3-白盒测试优缺点"><a href="#3-白盒测试优缺点" class="headerlink" title="3. 白盒测试优缺点"></a>3. 白盒测试优缺点</h3><p>优点：</p><ul><li>针对性强，便于快速定位，测试效率高</li><li>函数级别开始测试工作，缺陷修复成本低</li><li>通过不同的白盒覆盖指标有助于了解和衡量对被测对象的测试覆盖程度</li><li>有助于代码优化和缺陷预防</li></ul><p>缺点：</p><ul><li>对测试人员的技术要求高<ul><li>需要有一定的编程经验</li><li>白盒测试工程师需要具备广博的知识面</li></ul></li><li>成本高<ul><li>白盒测试的准备时间比较长</li></ul></li></ul><h3 id="4-白盒测试的问题"><a href="#4-白盒测试的问题" class="headerlink" title="4. 白盒测试的问题"></a>4. 白盒测试的问题</h3><ul><li>软件测试不是完备的</li><li>软件测试有风险</li><li>测试设计应该达到的目标<ul><li>提高效率</li><li>降低风险</li><li>在代码级别提高软件质量</li></ul></li></ul><h3 id="5-控制流分析技术"><a href="#5-控制流分析技术" class="headerlink" title="5. 控制流分析技术"></a>5. 控制流分析技术</h3><h4 id="1-什么是控制流分析？"><a href="#1-什么是控制流分析？" class="headerlink" title="1. 什么是控制流分析？"></a>1. 什么是控制流分析？</h4><p>就是根据程序的控制结构所反映的执行流流动规律建立起每一个程序执行点在控制结构中与其前驱或后继执行点在执行顺序上的对应关系，即流图。 流图直接反映了程序所有可能的执行路径以及执行流的运动规律</p><h4 id="2-控制流分析要解决的问题"><a href="#2-控制流分析要解决的问题" class="headerlink" title="2. 控制流分析要解决的问题"></a>2. 控制流分析要解决的问题</h4><ul><li>什么因素导致程序结构变的复杂</li><li>如何衡量程序结构的复杂程度</li><li>控制程序执行流程发生变化的主要因素是什么</li><li>如何测试这些因素并且确保测试的效率</li></ul><h4 id="3-控制流分析内容"><a href="#3-控制流分析内容" class="headerlink" title="3. 控制流分析内容"></a>3. 控制流分析内容</h4><ul><li>关注判定节点固有的复杂性<ul><li>焦点：判定表达式</li><li>方法：逻辑覆盖测试</li></ul></li><li>关注判定结构与循环结构对执行路径产生的影响<ul><li>焦点：路径</li><li>方法：基本（独立）路径测试</li></ul></li><li>关注循环结构本身复杂性<ul><li>焦点：循环体</li><li>方法：基于数据的静态分析</li></ul></li></ul><h3 id="6-常见的程序结构"><a href="#6-常见的程序结构" class="headerlink" title="6. 常见的程序结构"></a>6. 常见的程序结构</h3><h4 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="1. 线性结构"></a>1. 线性结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv51fwedj20cc05st95.jpg" alt="线性结构"></p><h4 id="2-条件判定结构"><a href="#2-条件判定结构" class="headerlink" title="2. 条件判定结构"></a>2. 条件判定结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv5mnh4kj20fw066jse.jpg" alt="条件判定结构"></p><h4 id="3-While循环结构"><a href="#3-While循环结构" class="headerlink" title="3. While循环结构"></a>3. While循环结构</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv69vq17j20e505tmxv.jpg" alt="While循环结构"></p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vv6z6f16j20cq05ht9f.jpg" alt="Do-While结构"></p><h3 id="7-白盒测试分类"><a href="#7-白盒测试分类" class="headerlink" title="7. 白盒测试分类"></a>7. 白盒测试分类</h3><p>可以分为两大类</p><h4 id="1-动态白盒测试"><a href="#1-动态白盒测试" class="headerlink" title="1. 动态白盒测试"></a>1. 动态白盒测试</h4><p>又称结构化测试。运行使用程序条件下找bug。</p><p>主要有逻辑覆盖测试、基本（独立）路径测试</p><h4 id="2-静态白盒测试"><a href="#2-静态白盒测试" class="headerlink" title="2. 静态白盒测试"></a>2. 静态白盒测试</h4><p>又称结构分析。不执行软件的条件下找出bug</p><p>主要有静态结构分析、静态质量度量、代码检查方法等等。</p><h3 id="8-逻辑覆盖猜测试（对判定）"><a href="#8-逻辑覆盖猜测试（对判定）" class="headerlink" title="8. 逻辑覆盖猜测试（对判定）"></a>8. 逻辑覆盖猜测试（对判定）</h3><p>原理：以程序内部的逻辑结构为基础的用例设计方法，通过对程序的逻辑结构的遍历，来实现测试对程序的覆盖。</p><p>关注点：判定表达式本身的复杂度</p><p>基本原则：对程序代码中所有的逻辑值，都需要测试其真值（True）和假值（False）的情况 </p><p>根据不同测试要求，逻辑覆盖测试可以分为：</p><ul><li>语句覆盖</li><li>判定覆盖（分支覆盖）</li><li>条件覆盖</li><li>判定-条件覆盖（分支-条件覆盖）</li><li>条件组合覆盖</li><li>路径覆盖</li></ul><h4 id="逻辑测试相关概念"><a href="#逻辑测试相关概念" class="headerlink" title="逻辑测试相关概念"></a>逻辑测试相关概念</h4><p>测试覆盖率 ：</p><ul><li>$覆盖率 &#x3D; 至少被执行一次的item总数 &#x2F; item总数$<ul><li>功能覆盖率：大致用于表示软件已经实现的功能和软件需要实现的功能之间的比例关系</li><li>结构覆盖率：包括语句覆盖率，分支覆盖率，路径覆盖率，循环覆盖率</li></ul></li><li>不一定要达到100%，也可以设置一个指标，达到这个指标后就认为达到了测试的效果</li></ul><h4 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h4><h5 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h5><p>设计测试用例时应保证程序中<strong>每一条可执行语句至少应该执行一次</strong>（点覆盖）</p><p>语句覆盖是最弱的一种覆盖标准</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w83fprpuj20h407u3z9.jpg" alt="语句覆盖"></p><h5 id="弊端："><a href="#弊端：" class="headerlink" title="弊端："></a>弊端：</h5><ul><li>关注语句，而非关注判定节点</li><li>对隐式分支无效</li></ul><h5 id="对策："><a href="#对策：" class="headerlink" title="对策："></a>对策：</h5><ul><li>优选测试数据</li><li>更强的覆盖准则：判定覆盖</li></ul><h4 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2. 判定覆盖"></a>2. 判定覆盖</h4><h5 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h5><p>又称分支覆盖。设计测试用例时，要保证程序中<strong>每个判定节点</strong>取得每种可能的结果至少一次。或者程序中每个判定的真分支和假分支至少执行一次。（边覆盖）</p><h5 id="局限性："><a href="#局限性：" class="headerlink" title="局限性："></a>局限性：</h5><ul><li>当判断节点中包含的是复合判定表达式时，即由多个简单判定条件（子条件）通过“与”、“或”关系连接而成的判定</li><li>此时，判定覆盖仅关心表达式的整体取值，并不关系局部组成，导致漏洞</li><li>故需要更严格的覆盖准则—-条件覆盖</li></ul><h4 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h4><h5 id="基本思想：-2"><a href="#基本思想：-2" class="headerlink" title="基本思想："></a>基本思想：</h5><p>设计测试用例时应保证程序中<strong>每个复合判定表达式</strong>中，每个简单的判定条件（子条件）的取真和取假情况至少执行一次。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w8s98hajj205v02jdg3.jpg" alt="条件覆盖"></p><p>实际上belike拆分成原子语句</p><p>局限性：</p><ul><li>并不能确保满足判定覆盖</li><li>相比判定覆盖，条件覆盖虽然进一步深入检查了判定节点中的每个子条件，但局部的完全覆盖不能保证对判定节点整体的完全覆盖</li><li>so需要更全面的覆盖准则—-判定-条件覆盖</li></ul><h4 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定-条件覆盖"></a>4. 判定-条件覆盖</h4><p>设计测试用例时，满足以下条件：</p><ul><li><p>判定节点的取真、取假分支至少执行一次</p></li><li><p>且每个简单的判定条件（子条件）的取真和取假情况也至少执行一次</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w9k3n7s8j20gr050q4w.jpg" alt="判定-条件覆盖"></p></li></ul><h4 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h4><p>每个判定节点中，所有简单判定条件（子条件）的所有可能的取值组合情况至少执行一次</p><p>本质：通过列真值表来得到完全覆盖</p><p>优势：</p><ul><li>覆盖前面all</li><li>方法简单，穷举法</li></ul><p>局限性：</p><ul><li>不能保证所有组合的路径被执行</li><li>测试用例太多</li><li>冗余严重</li></ul><h4 id="6-路径覆盖"><a href="#6-路径覆盖" class="headerlink" title="6. 路径覆盖"></a>6. 路径覆盖</h4><h5 id="基本要求："><a href="#基本要求：" class="headerlink" title="基本要求："></a>基本要求：</h5><p>要求设计足够的测试用例，运行被测程序，覆盖程序中all可能组合的路径</p><p>范围最广</p><h4 id="7-各方法之间关系"><a href="#7-各方法之间关系" class="headerlink" title="7. 各方法之间关系"></a>7. 各方法之间关系</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6w9x227dsj20hj07o401.jpg" alt="对比图"></p><h2 id="（二）逻辑覆盖测试-x2F-对判定的测试"><a href="#（二）逻辑覆盖测试-x2F-对判定的测试" class="headerlink" title="（二）逻辑覆盖测试&#x2F;对判定的测试"></a>（二）逻辑覆盖测试&#x2F;对判定的测试</h2><h2 id="（三）基本路径测试-x2F-对路径的测试"><a href="#（三）基本路径测试-x2F-对路径的测试" class="headerlink" title="（三）基本路径测试&#x2F;对路径的测试"></a>（三）基本路径测试&#x2F;对路径的测试</h2><h2 id="（四）静态白盒测试"><a href="#（四）静态白盒测试" class="headerlink" title="（四）静态白盒测试"></a>（四）静态白盒测试</h2><h2 id="（五）白盒测试工具Junit的使用"><a href="#（五）白盒测试工具Junit的使用" class="headerlink" title="（五）白盒测试工具Junit的使用"></a>（五）白盒测试工具Junit的使用</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;（一）白盒测试技术概述&quot;&gt;&lt;a href=&quot;#（一）白盒测试技术概述&quot; class=&quot;headerlink&quot; title=&quot;（一）白盒测试技术概述&quot;&gt;&lt;/a&gt;（一）白盒测试技术概述&lt;/h2&gt;&lt;h3 id=&quot;1-白盒测试基本原理&quot;&gt;&lt;a href=&quot;#1-白盒测试基</summary>
      
    
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="https://www.bebella.cc/2022/10/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.bebella.cc/2022/10/06/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</id>
    <published>2022-10-06T10:57:01.000Z</published>
    <updated>2022-10-06T12:42:00.118Z</updated>
    
    <content type="html"><![CDATA[<h4 id="6-什么是软件缺陷（BUG）"><a href="#6-什么是软件缺陷（BUG）" class="headerlink" title="6. 什么是软件缺陷（BUG）"></a>6. 什么是软件缺陷（BUG）</h4><p>第一个bug：</p><ul><li>Grace Hopper 计算机软件之母</li><li>1945.9.9</li><li>First actual case of bug being found</li></ul><p>著名软件故障：</p><ul><li>”算不准”的cpu【功能问题】</li><li>“哭泣”的狮子王【兼容性问题】</li><li>“失控”的动车【容错性问题】</li><li>“消失”的火星探测器【集成性问题】</li><li>“拒绝访问”的Gmail【性能问题】</li></ul><p>软件测试的必要性：</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vrviftnmj20jv05f0ud.jpg" alt="image.png"></p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vrvw4aewj20k002dwf8.jpg" alt="image.png"></p><p>软件缺陷的正式定义：（符合一个就算）</p><ol><li>软件测试员认为难以理解，不易使用，运行速度缓慢or最终用户认为软件是用效果不好的</li><li>软件未达到需求规格说明书中指明的功能</li><li>软件出现了需求规格说明书中不会出现的错误</li><li>软件功能超出需求规格说明书中指明的范围</li><li>软件未达到需求规格说明书总虽未指出但应该达到的指标</li></ol><h4 id="7-什么是测试用例"><a href="#7-什么是测试用例" class="headerlink" title="7. 什么是测试用例"></a>7. 什么是测试用例</h4><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6vs2h9qazj20e502l3z2.jpg" alt="image.png"></p><p>测试用例的基本属性</p><ul><li>典型性（代表性）</li><li>可测试性（可判定性）</li><li>可重现性</li><li>独立性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;6-什么是软件缺陷（BUG）&quot;&gt;&lt;a href=&quot;#6-什么是软件缺陷（BUG）&quot; class=&quot;headerlink&quot; title=&quot;6. 什么是软件缺陷（BUG）&quot;&gt;&lt;/a&gt;6. 什么是软件缺陷（BUG）&lt;/h4&gt;&lt;p&gt;第一个bug：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库访问技术</title>
    <link href="https://www.bebella.cc/2022/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.bebella.cc/2022/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8A%80%E6%9C%AF/</id>
    <published>2022-09-26T10:41:34.000Z</published>
    <updated>2022-09-27T02:07:40.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统数据库访问"><a href="#传统数据库访问" class="headerlink" title="传统数据库访问"></a>传统数据库访问</h2><p>编程语言访问数据库的步骤：</p><p>API（ .jar）—- 连接类：连接字符串，连接数据库 —- 命令类：SQL语句 —- 执行SQL —- 接收SQL执行的结果</p><p>注意点：</p><ul><li>参数化SQL命令（防止SQL注入攻击问题）<ul><li>SQL命令由多个字符串拼接而成</li></ul></li><li>抽取一个数据库访问辅助类</li><li>把连接字符串写进配置文件</li></ul><p>数据访问层DAO&#x2F;DAL</p><p>****Dao接口 —- ***DAOImpl</p><p>UserDao —- UserDaoImpl </p><p>UserDao —- UserDaoImp1 —- 专门访问数据库里的user表，CRUD</p><p>CourseDao —-</p><p>业务逻辑层（BLL&#x2F;Service）</p><p>UserService —- UserServiceImpl —- 专门处理User表</p><p>界面层（UI —- 前后端分离）</p><p>maven</p><p>问题：</p><p>一个项目里可能用到很多个 .jar</p><p>（1）手动管理麻烦</p><p>（2）重复很严重</p><p>（3）版本冲突</p><h2 id="JDBC访问数据库"><a href="#JDBC访问数据库" class="headerlink" title="JDBC访问数据库"></a>JDBC访问数据库</h2><h3 id="1-加载JDBC驱动程序"><a href="#1-加载JDBC驱动程序" class="headerlink" title="1.  加载JDBC驱动程序"></a>1.  加载JDBC驱动程序</h3><p>在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM，这通过反射实现。成功加载后，会将Driver类的实例注册到DriverManager类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 加载数据库驱动，此语句加载的是8.0版本的mysql</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="2.  连接数据库"></a>2.  连接数据库</h3><p>书写形式：协议：子协议：数据源标识 。 其中：</p><p>协议：在JDBC中总是以jdbc开始 。子协议：是桥连接的驱动程序或是数据库管理系统名称。  数据源标识：标记找到数据库来源的地址与连接端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connetcion</span> <span class="variable">connect</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// &quot;jdbc:mysql://DatabaseName?servertimezone&quot;,&quot;username&quot;,&quot;password&quot;</span></span><br><span class="line">connect = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///myschool?serverTimezone=Hongkong&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-创建一个Statement"><a href="#3-创建一个Statement" class="headerlink" title="3. 创建一个Statement"></a>3. 创建一个Statement</h3><p> 要执行SQL语句，必须获得java.sql.Statement实例，Statement实例分为以下3 种类型：</p><ul><li>执行静态SQL语句。通常通过Statement实例实现。</li><li>执行动态SQL语句。通常通过PreparedStatement实例实现。</li><li>执行数据库存储过程。通常通过CallableStatement实例实现。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statment statment = null;</span><br><span class="line">statment = connect.createStatement();</span><br></pre></td></tr></table></figure><h3 id="4-执行SQL语句"><a href="#4-执行SQL语句" class="headerlink" title="4. 执行SQL语句"></a>4. 执行SQL语句</h3><p>Statement 接口提供三种执行SQL语句的方法：</p><ul><li>executeQuery</li><li>executeUpdate</li><li>execute</li></ul><blockquote><p>   ResultSet executeQuery(String sqlString)：执行查询数据库的SQL语句，返回一个结果集（ResultSet）对象。<br>   int executeUpdate(String sqlString)：用于执行INSERT、UPDATE或DELETE语句以及SQL DDL语句，如：CREATE TABLE和DROP TABLE等<br>   execute(sqlString):用于执行返回多个结果集、多个更新计数或二者组合的语句。</p></blockquote><h3 id="5-处理结果-ResultSet"><a href="#5-处理结果-ResultSet" class="headerlink" title="5.  处理结果 ResultSet"></a>5.  处理结果 ResultSet</h3><p>两种情况：  </p><ul><li>执行更新返回的是本次操作影响到的记录数。  </li><li>执行查询返回的结果是一个ResultSet对象。</li></ul><p> ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs=statement.executeQuery(<span class="string">&quot;select * from user&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读出数据</span></span><br><span class="line"><span class="keyword">while</span> (rest.next()) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rest.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> rest.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(id + <span class="string">&quot; &quot;</span> + username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-关闭JDBC对象"><a href="#6-关闭JDBC对象" class="headerlink" title="6.  关闭JDBC对象"></a>6.  关闭JDBC对象</h3><p>  操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源，关闭顺序和声明顺序相反：</p><ul><li>关闭记录集</li><li>关闭声明  </li><li>关闭连接对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeRs</span><span class="params">(ResultSet rs)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(rs != <span class="literal">null</span> )&#123;</span><br><span class="line"> rs.close();</span><br><span class="line"> rs = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//关闭执行方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeStmt</span><span class="params">(Statement stmt)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(stmt != <span class="literal">null</span> )&#123;</span><br><span class="line"> stmt.close();</span><br><span class="line"> stmt = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">(Connection conn)</span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="literal">null</span> )&#123;</span><br><span class="line"> conn.close();</span><br><span class="line"> conn = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传统数据库访问&quot;&gt;&lt;a href=&quot;#传统数据库访问&quot; class=&quot;headerlink&quot; title=&quot;传统数据库访问&quot;&gt;&lt;/a&gt;传统数据库访问&lt;/h2&gt;&lt;p&gt;编程语言访问数据库的步骤：&lt;/p&gt;
&lt;p&gt;API（ .jar）—- 连接类：连接字符串，连接数据库 </summary>
      
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>面向对象设计原则与设计模式</title>
    <link href="https://www.bebella.cc/2022/09/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.bebella.cc/2022/09/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-09-26T09:59:09.000Z</published>
    <updated>2022-09-26T10:41:16.581Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象设计原则：面向**<u>接口</u>**编程</p><p>程序错误：看报错信息</p><p>配置文件的作用：什么都可以写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象设计原则：面向**&lt;u&gt;接口&lt;/u&gt;**编程&lt;/p&gt;
&lt;p&gt;程序错误：看报错信息&lt;/p&gt;
&lt;p&gt;配置文件的作用：什么都可以写&lt;/p&gt;
</summary>
      
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/categories/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>Kaggle入门</title>
    <link href="https://www.bebella.cc/2022/09/23/Kaggle%E5%85%A5%E9%97%A8/"/>
    <id>https://www.bebella.cc/2022/09/23/Kaggle%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-23T05:47:59.000Z</published>
    <updated>2022-09-27T09:17:02.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Recap-of-main-ML-algorithms"><a href="#1-Recap-of-main-ML-algorithms" class="headerlink" title="1. Recap of main ML algorithms"></a>1. Recap of main ML algorithms</h2><h3 id="1-Linear"><a href="#1-Linear" class="headerlink" title="1 Linear"></a>1 Linear</h3><p>advantage:</p><p>适合稀疏的数据</p><p>disadvantage:</p><p>很多数据不能被简单的一条线分成两类</p><h3 id="2-Tree-based"><a href="#2-Tree-based" class="headerlink" title="2 Tree-based"></a>2 Tree-based</h3><p>决策树、随机森林、GBDT</p><p>需要大量分裂，很难找到线性相关性</p><h3 id="3-kNN（k最近邻）"><a href="#3-kNN（k最近邻）" class="headerlink" title="3  kNN（k最近邻）"></a>3  kNN（k最近邻）</h3><h3 id="4-Neural-Networks"><a href="#4-Neural-Networks" class="headerlink" title="4  Neural Networks"></a>4  Neural Networks</h3><h2 id="2-Feature-Preprocessing-and-Generation"><a href="#2-Feature-Preprocessing-and-Generation" class="headerlink" title="2. Feature Preprocessing and Generation"></a>2. Feature Preprocessing and Generation</h2><h3 id="1-Numeric-Features"><a href="#1-Numeric-Features" class="headerlink" title="1 Numeric Features"></a>1 Numeric Features</h3><p>Tree-based 不需要scaling</p><p>但是Non-tree-based就非常依赖scaling</p><h4 id="preprocessing"><a href="#preprocessing" class="headerlink" title="preprocessing"></a>preprocessing</h4><h5 id="a-0-1-正则化"><a href="#a-0-1-正则化" class="headerlink" title="a. 0-1 正则化"></a>a. 0-1 正则化</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.MinMaxScaler</span><br></pre></td></tr></table></figure><p>$X &#x3D; (X - X.min()) &#x2F; (X.max() - X.min()) $</p><h5 id="b-标准正则化"><a href="#b-标准正则化" class="headerlink" title="b. 标准正则化"></a>b. 标准正则化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.StandardScaler</span><br></pre></td></tr></table></figure><p>$X &#x3D; (X - X.mean()) &#x2F; X.std() $</p><h5 id="c-异常值处理"><a href="#c-异常值处理" class="headerlink" title="c. 异常值处理"></a>c. 异常值处理</h5><ul><li>设定取值范围</li></ul><h5 id="d-rank"><a href="#d-rank" class="headerlink" title="d. rank"></a>d. rank</h5><ul><li>映射</li><li><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6h0k7hdnkj20c203ct91.jpg" alt="rank"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.stats.rankdata</span><br></pre></td></tr></table></figure><p>非树型 或 神经网络可以用：</p><ul><li><p>Log </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.log(1 + x)</span><br></pre></td></tr></table></figure></li><li><p>Raising to the power &lt; 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(x + 2/3)</span><br></pre></td></tr></table></figure></li></ul><h3 id="类别特征与顺序特征"><a href="#类别特征与顺序特征" class="headerlink" title="类别特征与顺序特征"></a>类别特征与顺序特征</h3><p>Label Encoding</p><h4 id="feature-generation"><a href="#feature-generation" class="headerlink" title="feature generation"></a>feature generation</h4><p>powered by:</p><ul><li>prior knowledge</li><li>EDA</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Recap-of-main-ML-algorithms&quot;&gt;&lt;a href=&quot;#1-Recap-of-main-ML-algorithms&quot; class=&quot;headerlink&quot; title=&quot;1. Recap of main ML algorithms&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="DataScience" scheme="https://www.bebella.cc/categories/DataScience/"/>
    
    
    <category term="Kaggle" scheme="https://www.bebella.cc/tags/Kaggle/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化与主从复制</title>
    <link href="https://www.bebella.cc/2022/09/23/%E3%80%90%E5%AE%8C%E7%BB%93%E3%80%91Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://www.bebella.cc/2022/09/23/%E3%80%90%E5%AE%8C%E7%BB%93%E3%80%91Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2022-09-22T17:40:40.000Z</published>
    <updated>2022-09-27T08:15:05.077Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1. 什么是持久化"></a>1. 什么是持久化</h3><p>​持久化可以理解为数据的永久存储，就是将数据存储到一个不会丢失的地方。如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化 的，而放在磁盘就是一种持久化。 </p><h3 id="2-Redis的持久化"><a href="#2-Redis的持久化" class="headerlink" title="2. Redis的持久化"></a>2. Redis的持久化</h3><ul><li><p>Redis 是内存型数据库，一般来用作缓存。</p></li><li><p>Redis的数据存储在内存中，系统宕机or重启，或Redis崩溃、重启，所有数据丢失</p></li><li><p>为解决此问题，提供两种机制对数据进行持久化储存，方便故障发生后迅速恢复数据。</p><blockquote><p>​保存在内存的数据有一个特点， 就是断电消失，因此一旦 Redis 宕机了，重启以后保存在 Redis 里面的数据就会消失， 此时服务器在 Redis 里面获取不到缓存，就会让缓存无法命中，导致缓存雪崩，请求直接打到 MySQL 上最后让 MySQL 也宕机。 因此我们需要 Redis 持久化来做灾难恢复、数据恢复还有数据库高可用。</p></blockquote></li></ul><h4 id="1-RDB文件"><a href="#1-RDB文件" class="headerlink" title="1. RDB文件"></a>1. RDB文件</h4><p>​redis database backup file，备份文件，默认持久化方式。</p><blockquote><p>就是在指定的时间间隔内将内存中的数据集快照写入磁盘。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为 RDB 文件，保存了在某个时间点的全部数据，默认是保存在当前运行目录，默认文件名是 <strong>dump.rdb</strong>，该文件会自动创建。</p><p>保存数据是在单独的进程中写文件。</p></blockquote><p>RDB触发条件：</p><ol><li><p>save</p><blockquote><p>save 命令会用主进程执行RDB，其他进程可能会被阻塞。</p></blockquote></li><li><p>bgsave （后台保存）</p><blockquote><p>可以异步执行 RDB：执行后会开启独立进程完成 RDB，主进程可以继续处理用户请求，不受影响</p></blockquote></li><li><p>Redis停机or宕机</p></li><li><p>触发RDB条件</p><blockquote><p>配置文件中有以下参数。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghd898iuj205c02p0sv.jpg" alt="image-20220923021247332.png"></p><p>save <seconds> <changes> ：当在<strong>N 秒内数据集至少有 M 个 key</strong> 改动这一条件被满足时， 自动保存一 次数据集</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghekfaegj208z01bjri.jpg" alt="image-20220923021413130.png"></p><p>配置文件名。默认为dump.rdb</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6gheuwxgwj20cl02d3yw.jpg" alt="image-20220923021434324.png"></p><p>配置存储路径，默认为当前目录。</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghf5o0jdj20b501iaaf.jpg" alt="image-20220923021457606.png"></p><p>是否压缩RDB文件，建议no。</p></blockquote></li></ol><h4 id="2-AOF日志"><a href="#2-AOF日志" class="headerlink" title="2. AOF日志"></a>2. AOF日志</h4><p>​Append-only File，Redis 每次接收到一条<strong>更新数据</strong>的命令时，它将把该命令写到一个 AOF 文件中（只记录写操作，读操作不记录）。当 Redis 重启时，它通过执行 AOF 文件中所有的命令来恢复数据。 </p><p>三种像aof文件写命令数据的策略：</p><ol><li>no</li><li>always</li><li>everysec</li></ol><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6ghgp0mthj20gp02zdgs.jpg" alt="image-20220923021916762.png"></p><h3 id="3-RDB与AOF优缺点比较"><a href="#3-RDB与AOF优缺点比较" class="headerlink" title="3. RDB与AOF优缺点比较"></a>3. RDB与AOF优缺点比较</h3><p>RDB：</p><ul><li>体积小，适合备份传输</li><li>性能比AOF好，（AOF需要写入日志到文件中）。RDB恢复更快。</li></ul><p>但是：</p><ul><li>服务器故障时会丢失最后一次备份之后的数据。</li><li>Redis 保存rdb时， fork子进程的这个操作期间, Redis服务会停止响应(一般是毫秒级)，但如果数据量大且cpu时间紧张，则停止响应的时间可能长达1秒</li></ul><p>AOF：</p><ul><li>充分保证数据的持久化，正确的配置一般最多丢失1秒的数据</li><li>aof 文件内容是以Redis协议格式保存， 易读</li></ul><p>但是：</p><ul><li>文件RDB文件大，速度较慢</li><li>重新启动redis时会极低的概率会导致无法将数据集恢复成保存时的原样(概率极低, 但确实出现过)</li></ul><h3 id="4-相关配置（cmd版）"><a href="#4-相关配置（cmd版）" class="headerlink" title="4. 相关配置（cmd版）"></a>4. 相关配置（cmd版）</h3><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ RDB  ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#rdb文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录。默认为当前目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">#aof文件名, 保存目录由 dir 参数决定</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#aof持久化策略的配置</span><br><span class="line">#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line"># 手动重写方式：命令 bgrewriteaop</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure><h3 id="5-Docker下持久化"><a href="#5-Docker下持久化" class="headerlink" title="5.  Docker下持久化"></a>5.  Docker下持久化</h3><h5 id="docker数据卷"><a href="#docker数据卷" class="headerlink" title="docker数据卷"></a>docker数据卷</h5><p>Docker 容器删除后，在容器中产生的数据就不在了，Docker 容器和外部机器不可以直接交换文件，容器之间想要进行数据交互就要通过数据卷</p><blockquote><p><strong>数据卷是什么：</strong></p><ul><li><p>数据卷是宿主机中的一个目录或文件</p></li><li><p>当容器目录和数据卷目录绑定后，对方的修改会立即同步</p></li><li><p>一个数据卷可以被多个容器同时挂载</p></li><li><p>一个容器也可以被挂载多个数据卷</p></li></ul><p><strong>数据卷的作用：</strong></p><ul><li><p>容器数据持久化</p></li><li><p>外部机器和容器间接通信</p></li><li><p>容器之间数据交换</p></li></ul></blockquote><h5 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h5><ol><li>创建redis容器并挂载数据卷<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name redis_1 -p 6379:6379 -v /e/redis/data:/data redis</span></span><br></pre></td></tr></table></figure>数据卷的实现: 创建启动容器时，使用–v 参数来设置数据卷</li></ol><p>语法：docker run -v &#x2F;宿主机绝对路径目录:&#x2F;容器内目录 镜像名…..</p><ol start="2"><li>使用 redis-cli.exe 连接 redis 容器，写入数据，执行 RDB 操作</li><li>查看实现宿主机的目录和容器内目录的映射 </li><li>恢复数据：停止然后再次启动Redis容器</li></ol><h5 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h5><ol><li>创建redis容器并挂载数据卷</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -d --name redis_2 -p 6379:6379 -v /d/redis/data:/data redis --appendonly <span class="built_in">yes</span></span></span><br><span class="line">// 该命令表示 redis_2 容器开启 AOF 持久化模式。但是，该参数只在当前命令 中有效</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用 redis-cli.exe 连接 redis 容器，写入数据，执行 RDB 操作</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l8cxe0sij20bq05m758.jpg" alt="image.png"></p></li><li><p>查看实现宿主机的目录和容器内目录的映射 </p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l8dcvx1sj206803cjrh.jpg" alt="image.png"></p></li><li><p>恢复数据：停止然后再次启动Redis容器</p></li></ol><h5 id="使用配置文件修改容器内Redis参数"><a href="#使用配置文件修改容器内Redis参数" class="headerlink" title="使用配置文件修改容器内Redis参数"></a>使用配置文件修改容器内Redis参数</h5><ol><li>创建”E:\redis\conf”文件夹，用于存放 redis.conf 文件；</li><li>创建redis.conf文件</li><li>修改所需参数</li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Q-什么是主从复制？"><a href="#Q-什么是主从复制？" class="headerlink" title="Q: 什么是主从复制？"></a>Q: 什么是主从复制？</h4><blockquote><p>主从复制，是将多台数据库服务器分为主节点（master）和从节点（slaver），主节点数据更新后会根据配置和策略，自动同步到从节点上，从而保证主从节点中存有相同的数据。</p><p>常见结构：</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l7jqt3r8j208g06t74s.jpg" alt="主从复制结构"></p></blockquote><h4 id="Q-主从复制作用？"><a href="#Q-主从复制作用？" class="headerlink" title="Q: 主从复制作用？"></a>Q: 主从复制作用？</h4><blockquote><ul><li>提升数据库系统的请求处理能力。</li><li>单个节点能够支撑的读流量有限。部署多个节点，并构成主从关系，主从节点一起提供服务</li><li>默认实现读写分离机制，Master 以写为主，Slave 以读为主，提升系统的缓存读写性能。</li><li>容灾快速恢复，提升整个系统的可用性。</li><li>因为从节点中有主节点数据的副本，当主节点宕机后，可以立刻提升其中一个从节点为主节点，继续提供服务</li></ul></blockquote><h4 id="Q-主从复制原理？"><a href="#Q-主从复制原理？" class="headerlink" title="Q: 主从复制原理？"></a>Q: 主从复制原理？</h4><p>直观的做法是主节点产生一份数据的快照发送给从节点，以快照数据为基准，将之后增量的数据变更同步给从节点，保证主从数据的一致。总体来看，主从复制一般包含全量数据同步、增量同步两个阶段。 </p><blockquote><ul><li>全量数据同步 </li><li>主节点产生一份全量数据的快照（RDB 文件），并将此快照发送给从节点。且从产生快照时刻起，记录新接收到的写命令。当快照发送完成后，将累积的写命令发送绐从节点，从节点执行这些写命令。一般用于主从节点首次数据同步，完成基准数据。</li><li>增量同步（命令传播） </li><li>全量数据同步完成后，主节点将执行过的写命令源源不断地发送给从节点，从节点执行这些命令，保证主从节点中数据有相同的变更，保证主从节点数据的一致。</li></ul></blockquote><h3 id="redis下主从复制"><a href="#redis下主从复制" class="headerlink" title="redis下主从复制"></a>redis下主从复制</h3><p>参考课件</p><h3 id="docker下的redis主从复制"><a href="#docker下的redis主从复制" class="headerlink" title="docker下的redis主从复制"></a>docker下的redis主从复制</h3><p>以一主二从为例。</p><ol><li><p>给三台Redis分配端口号</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-master -p 6379:6379 -d redis redis-server</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-slaver1 -p 6380:6379 -d redis redis-server</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name redis-slaver2 -p 6381:6379 -d redis redis-server</span></span><br></pre></td></tr></table></figure></li><li><p>创建三个redis配置文件</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l7wdds09j20cl03rjsu.jpg" alt="三个配置文件"></p></li><li><p>查询三个redis在容器内ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 容器id可在docker desktop内复制</span><br><span class="line">docker inspect containerid(容器id)</span><br></pre></td></tr></table></figure></li><li><p>修改两个slave节点的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// slaveof &lt;master ipaddress&gt; &lt;master port&gt;</span><br><span class="line">slaveof 172.17.0.2 6379</span><br></pre></td></tr></table></figure></li><li><p>启动三台服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> (1)启动master:</span><br><span class="line"> docker run -id --name redis_master -p 6379:6379 --privileged=true -v /d/redis/data:/data -v /d/redis/conf/redis_6379.conf:/etc/redis/redis_6379.conf redis redis-server /etc/redis/redis_6379.conf</span><br><span class="line">   </span><br><span class="line">  (2)启动slave1:</span><br><span class="line"> docker run -id --name redis_slave1 -p 6380:6379 --privileged=true -v /d/redis/conf/redis_6380.conf:/etc/redis/redis_6380.conf redis redis-server /etc/redis/redis_6380.conf</span><br><span class="line"></span><br><span class="line">  (3)启动slave2:</span><br><span class="line">docker run -id --name redis_slave2 -p 6381:6379 --privileged=true -v /d/redis/conf/redis_6381.conf:/etc/redis/redis_6381.conf redis redis-server /etc/redis/redis_6381.conf</span><br></pre></td></tr></table></figure></li><li><p>查询主从身份</p><p>进入redis，输入<code>info replication</code></p></li><li><p>测试数据是否同步</p><p><img src="https://tva1.sinaimg.cn/large/95dcfebagy1h6l84i2dtoj20fe04s74e.jpg" alt="结果"></p></li></ol><hr><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/182972002">https://zhuanlan.zhihu.com/p/182972002</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h2&gt;&lt;h3 id=&quot;1-什么是持久化&quot;&gt;&lt;a href=&quot;#1-什么是持久化&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="NoSQL" scheme="https://www.bebella.cc/categories/NoSQL/"/>
    
    
    <category term="Redis" scheme="https://www.bebella.cc/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>反射机制与配置文件</title>
    <link href="https://www.bebella.cc/2022/09/22/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://www.bebella.cc/2022/09/22/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2022-09-22T05:49:48.000Z</published>
    <updated>2022-09-26T10:49:27.372Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="1. 什么是反射"></a>1. 什么是反射</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性（包括私有的方法和属性）；</li><li>这种<strong>动态获取的信息</strong>以及<strong>动态调用对象的方法</strong>的功能称为java语言的反射机制。</li></ul><p>反射就是把java类中的各种成分映射成一个个的Java对象。</p><blockquote><p><strong>反射是框架设计的灵魂</strong><br><strong>使用前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件 ( 字节码 )，而反射使用的就是Class类中的方法</strong></p><p><strong>注意：在运行期间，一个类，只有一个Class对象产生。</strong></p></blockquote><h2 id="2-反射用途"><a href="#2-反射用途" class="headerlink" title="2. 反射用途"></a>2. 反射用途</h2><p>​在日常的第三方应用开发反射来获取所需的私有成员或是方法。经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用 Java 的反射机制通过反射来获取所需的私有成员或是方法。</p><p>​当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值，这样就起到保护用户隐私的目的。</p><h2 id="3-例子"><a href="#3-例子" class="headerlink" title="3. 例子"></a>3. 例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-什么是反射&quot;&gt;&lt;a href=&quot;#1-什么是反射&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是反射&quot;&gt;&lt;/a&gt;1. 什么是反射&lt;/h2&gt;&lt;h3 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="软工实践" scheme="https://www.bebella.cc/tags/%E8%BD%AF%E5%B7%A5%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello</title>
    <link href="https://www.bebella.cc/2022/09/22/Hello/"/>
    <id>https://www.bebella.cc/2022/09/22/Hello/</id>
    <published>2022-09-22T05:36:08.000Z</published>
    <updated>2022-09-22T05:38:12.889Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, I am Bella z. It would be my first blog and I would try to share my study notes, daily life, what I like etc.</p><p>Welcome!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hello, I am Bella z. It would be my first blog and I would try to share my study notes, daily life, what I like etc.&lt;/p&gt;
&lt;p&gt;Welcome!&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.bebella.cc/2022/09/20/hello-world/"/>
    <id>https://www.bebella.cc/2022/09/20/hello-world/</id>
    <published>2022-09-20T14:32:34.318Z</published>
    <updated>2022-09-20T14:32:34.318Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
