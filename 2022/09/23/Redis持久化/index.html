<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis持久化"><meta name="keywords" content="NoSQL"><meta name="author" content="Bella"><meta name="copyright" content="Bella"><title>Redis持久化 | Bella</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Bella" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">1. 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">2. Redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RDB%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. RDB文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AOF%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. AOF日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-RDB%E4%B8%8EAOF%E4%BC%98%E7%BC%BA%E7%82%B9%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.</span> <span class="toc-text">#### 3. RDB与AOF优缺点比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">4. 相关配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">RDB:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">AOF</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Bella</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://wx2.sinaimg.cn/mw2000/006097Pbly1h5v3jgrowvj335s23vhdv.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Bella</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Redis持久化</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-23</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="1-持久化"><a href="#1-持久化" class="headerlink" title="1. 持久化"></a>1. 持久化</h2><h3 id="1-什么是持久化"><a href="#1-什么是持久化" class="headerlink" title="1. 什么是持久化"></a>1. 什么是持久化</h3><p>​		持久化可以理解为数据的永久存储，就是将数据存储到一个不会丢失的地方。如果把数据放在内存中，电脑关闭或重启数据就会丢失，所以放在内存中的数据不是持久化 的，而放在磁盘就是一种持久化。 </p>
<h3 id="2-Redis的持久化"><a href="#2-Redis的持久化" class="headerlink" title="2. Redis的持久化"></a>2. Redis的持久化</h3><ul>
<li><p>Redis 是内存型数据库，一般来用作缓存。</p>
</li>
<li><p>Redis的数据存储在内存中，系统宕机or重启，或Redis崩溃、重启，所有数据丢失</p>
</li>
<li><p>为解决此问题，提供两种机制对数据进行持久化储存，方便故障发生后迅速恢复数据。</p>
<blockquote>
<p>​		保存在内存的数据有一个特点， 就是断电消失，因此一旦 Redis 宕机了，重启以后保存在 Redis 里面的数据就会消失， 此时服务器在 Redis 里面获取不到缓存，就会让缓存无法命中，导致缓存雪崩，请求直接打到 MySQL 上最后让 MySQL 也宕机。 因此我们需要 Redis 持久化来做灾难恢复、数据恢复还有数据库高可用。</p>
</blockquote>
</li>
</ul>
<h4 id="1-RDB文件"><a href="#1-RDB文件" class="headerlink" title="1. RDB文件"></a>1. RDB文件</h4><p>​		redis database backup file，备份文件，默认持久化方式。</p>
<blockquote>
<p>就是在指定的时间间隔内将内存中的数据集快照写入磁盘。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
<p>快照文件称为 RDB 文件，保存了在某个时间点的全部数据，默认是保存在当前运行目录，默认文件名是 <strong>dump.rdb</strong>，该文件会自动创建。</p>
<p>保存数据是在单独的进程中写文件。</p>
</blockquote>
<p>RDB触发条件：</p>
<ol>
<li><p>save</p>
<blockquote>
<p>save 命令会用主进程执行RDB，其他进程可能会被阻塞。</p>
</blockquote>
</li>
<li><p>bgsave （后台保存）</p>
<blockquote>
<p>可以异步执行 RDB：执行后会开启独立进程完成 RDB，主进程可以继续处理用户请求，不受影响</p>
</blockquote>
</li>
<li><p>Redis停机or宕机</p>
</li>
<li><p>触发RDB条件</p>
<blockquote>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220923021247332.png" alt="image-20220923021247332"></p>
<p>配置文件中有以下参数。</p>
<p>save <seconds> <changes> ：当在<strong>N 秒内数据集至少有 M 个 key</strong> 改动这一条件被满足时， 自动保存一 次数据集</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220923021413130.png" alt="image-20220923021413130"></p>
<p>配置文件名。默认为dump.rdb</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220923021434324.png" alt="image-20220923021434324"></p>
<p>配置存储路径，默认为当前目录。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220923021457606.png" alt="image-20220923021457606"></p>
<p>是否压缩RDB文件，建议no。</p>
</blockquote>
</li>
</ol>
<h4 id="2-AOF日志"><a href="#2-AOF日志" class="headerlink" title="2. AOF日志"></a>2. AOF日志</h4><p>​	Append-only File，Redis 每次接收到一条<strong>更新数据</strong>的命令时，它将把该命令写到一个 AOF 文件中（只记录写操作，读操作不记录）。当 Redis 重启时，它通过执行 AOF 文件中所有的命令来恢复数据。 </p>
<p>三种像aof文件写命令数据的策略：</p>
<ol>
<li>no</li>
<li>always</li>
<li>everysec</li>
</ol>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20220923021916762.png" alt="image-20220923021916762"></p>
<h3 id="3-RDB与AOF优缺点比较"><a href="#3-RDB与AOF优缺点比较" class="headerlink" title="#### 3. RDB与AOF优缺点比较"></a>#### 3. RDB与AOF优缺点比较</h3><p>RDB：</p>
<ul>
<li>体积小，适合备份传输</li>
<li>性能比AOF好，（AOF需要写入日志到文件中）。RDB恢复更快。</li>
</ul>
<p>但是：</p>
<ul>
<li>服务器故障时会丢失最后一次备份之后的数据。</li>
<li>Redis 保存rdb时， fork子进程的这个操作期间, Redis服务会停止响应(一般是毫秒级)，但如果数据量大且cpu时间紧张，则停止响应的时间可能长达1秒</li>
</ul>
<p>AOF：</p>
<ul>
<li>充分保证数据的持久化，正确的配置一般最多丢失1秒的数据</li>
<li>aof 文件内容是以Redis协议格式保存， 易读</li>
</ul>
<p>但是：</p>
<ul>
<li>文件RDB文件大，速度较慢</li>
<li>重新启动redis时会极低的概率会导致无法将数据集恢复成保存时的原样(概率极低, 但确实出现过)</li>
</ul>
<h4 id="4-相关配置"><a href="#4-相关配置" class="headerlink" title="4. 相关配置"></a>4. 相关配置</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB:"></a>RDB:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">################################ RDB  ################################</span><br><span class="line"># 快照配置</span><br><span class="line"># 注释掉“save”这一行配置项就可以让保存数据库功能失效</span><br><span class="line"># 设置sedis进行数据库镜像的频率。</span><br><span class="line"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化） </span><br><span class="line"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line">#rdb文件的名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录。默认为当前目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>



<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">############################## APPEND ONLY MODE ###############################</span><br><span class="line">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line">#aof文件名, 保存目录由 dir 参数决定</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line">#aof持久化策略的配置</span><br><span class="line">#no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快。</span><br><span class="line">#always表示每次写入都执行fsync，以保证数据同步到磁盘。</span><br><span class="line">#everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line">#aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。</span><br><span class="line"># 手动重写方式：命令 bgrewriteaop</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line">#aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项（redis宕机或者异常终止不会造成尾部不完整现象。）出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。</span><br><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure>



<hr>
<p>参考链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/182972002">https://zhuanlan.zhihu.com/p/182972002</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Bella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.bebella.cc/2022/09/23/Redis持久化/">https://www.bebella.cc/2022/09/23/Redis持久化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/09/22/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"><span>反射机制与配置文件</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://wx2.sinaimg.cn/mw2000/006097Pbly1h5v3jgrowvj335s23vhdv.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By Bella</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>